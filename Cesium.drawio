<mxfile host="app.diagrams.net" modified="2020-09-10T03:46:42.053Z" agent="5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36" etag="XpqWvFaRdHtTw0uRD2fp" version="13.6.6" type="github">
  <diagram id="9aOjrgbC5z1DzK8ZOaCG" name="Page-1">
    <mxGraphModel dx="7950" dy="3505" grid="0" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="0" pageScale="1" pageWidth="827" pageHeight="1169" background="none" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="zrCMIupTtKye5h8rk7Vh-70" value="QuadtreePrimitive.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=135;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="312" y="8959" width="2931" height="3181" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-41" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* Updates terrain heights. 更新地形高度&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;QuadtreePrimitive.prototype.endFrame = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var passes = frameState.passes;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!passes.render&amp;nbsp; &amp;nbsp; || frameState.mode === SceneMode.MORPHING&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Only process the load queue for a single pass.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Don&#39;t process the load queue or update heights during the morph flights.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Load/create resources for terrain and imagery. Prepare texture re-projections for the next frame.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 加载/创建地形和影响资源。为下一帧的贴图投影做准备&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; processTileLoadQueue(this, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; updateHeights(this, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; updateTileLoadProgress(this, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;snapToPoint=0;rotatable=0;" parent="zrCMIupTtKye5h8rk7Vh-70" vertex="1">
          <mxGeometry x="75" y="245" width="586" height="268" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-44" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-41" vertex="1">
          <mxGeometry x="116" y="98" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-45" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-41" vertex="1">
          <mxGeometry x="400" y="98" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-46" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-41" vertex="1">
          <mxGeometry x="264" y="210" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-47" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-41" vertex="1">
          <mxGeometry x="264" y="224" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-48" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-41" vertex="1">
          <mxGeometry x="264" y="239" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-49" value="&lt;div&gt;&lt;b&gt;function processTileLoadQueue(primitive, frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileLoadQueueHigh = primitive._tileLoadQueueHigh;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileLoadQueueMedium = primitive._tileLoadQueueMedium;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileLoadQueueLow = primitive._tileLoadQueueLow;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileLoadQueueHigh.length === 0 &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileLoadQueueMedium.length === 0 &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileLoadQueueLow.length === 0&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Remove any tiles that were not used this frame beyond the number&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // we&#39;re allowed to keep.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive._tileReplacementQueue.trimTiles(primitive.tileCacheSize);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var endTime = getTimestamp() + primitive._loadQueueTimeSlice;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileProvider = primitive._tileProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var didSomeLoading = processSinglePriorityLoadQueue(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;endTime,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileLoadQueueHigh,&amp;nbsp;&lt;/b&gt;&lt;b&gt;false&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; didSomeLoading = processSinglePriorityLoadQueue(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;endTime,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileLoadQueueMedium,&amp;nbsp;&lt;/b&gt;&lt;b&gt;didSomeLoading&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; processSinglePriorityLoadQueue(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;endTime,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileLoadQueueLow,&amp;nbsp;&lt;/b&gt;&lt;b&gt;didSomeLoading&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;comic=0;rotatable=0;recursiveResize=0;" parent="zrCMIupTtKye5h8rk7Vh-70" vertex="1">
          <mxGeometry x="886" y="203" width="835" height="359" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-51" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-49" vertex="1">
          <mxGeometry x="816" y="309" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-50" value="&lt;div&gt;&lt;b&gt;function processSinglePriorityLoadQueue(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tileProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; endTime,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; loadQueue,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; didSomeLoading&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (tileProvider.computeTileLoadPriority !== undefined) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; loadQueue.sort(sortByLoadPriority);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 一是不超过列表范围，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 二是运行时间不超过 _loadQueneTimeSlice（默认为 5ms）或之前没有进行过 load&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var i = 0, len = loadQueue.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; i &amp;lt; len &amp;amp;&amp;amp; (getTimestamp() &amp;lt; endTime || !didSomeLoading);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ++i&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var tile = loadQueue[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; primitive._tileReplacementQueue.markTileRendered(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.loadTile(frameState, tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; didSomeLoading = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return didSomeLoading;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;comic=0;portConstraintRotation=0;rotatable=0;" parent="zrCMIupTtKye5h8rk7Vh-70" vertex="1">
          <mxGeometry x="2172" y="319" width="486" height="394" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-60" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-50" vertex="1">
          <mxGeometry x="349" y="295" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-61" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-50" vertex="1">
          <mxGeometry x="235" y="309" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="cho-rxJkQNWqNleOSbak-20" style="orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=2;" parent="zrCMIupTtKye5h8rk7Vh-70" source="_qH6-IZlokEgzrvQ4-RS-46" target="_qH6-IZlokEgzrvQ4-RS-49" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="693" y="-5905" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-54" style="orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#000000;" parent="zrCMIupTtKye5h8rk7Vh-70" source="_qH6-IZlokEgzrvQ4-RS-51" target="_qH6-IZlokEgzrvQ4-RS-50" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-58" value="&lt;div&gt;&lt;b&gt;function updateHeights(primitive, frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!primitive.tileProvider.ready) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tryNextFrame = scratchArray;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tryNextFrame.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tilesToUpdateHeights = primitive._tileToUpdateHeights;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainProvider = primitive._tileProvider.terrainProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var startTime = getTimestamp();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var timeSlice = primitive._updateHeightsTimeSlice;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var endTime = startTime + timeSlice;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var mode = frameState.mode;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var projection = frameState.mapProjection;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var ellipsoid = primitive.tileProvider.tilingScheme.ellipsoid;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var i;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; while (tilesToUpdateHeights.length &amp;gt; 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var tile = tilesToUpdateHeights[0];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!defined(tile.data) || !defined(tile.data.mesh)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Tile isn&#39;t loaded enough yet, so try again next frame if this tile is still&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // being rendered.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var selectionResult =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tile._lastSelectionResultFrame === primitive._lastSelectionFrameNumber&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ? tile._lastSelectionResult&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : TileSelectionResult.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; selectionResult === TileSelectionResult.RENDERED ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; selectionResult === TileSelectionResult.CULLED_BUT_NEEDED&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tryNextFrame.push(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tilesToUpdateHeights.shift();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._lastTileIndex = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; continue;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var customData = tile.customData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var customDataLength = customData.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var timeSliceMax = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (i = primitive._lastTileIndex; i &amp;lt; customDataLength; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var data = customData[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (tile.level &amp;gt; data.level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (!defined(data.positionOnEllipsoidSurface)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // cartesian has to be on the ellipsoid surface for `ellipsoid.geodeticSurfaceNormal`&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.positionOnEllipsoidSurface = Cartesian3.fromRadians(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.positionCartographic.longitude,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.positionCartographic.latitude,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 0.0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ellipsoid&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (mode === SceneMode.SCENE3D) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var surfaceNormal = ellipsoid.geodeticSurfaceNormal(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.positionOnEllipsoidSurface,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchRay.direction&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // compute origin point&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Try to find the intersection point between the surface normal and z-axis.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var rayOrigin = ellipsoid.getSurfaceNormalIntersectionWithZAxis(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.positionOnEllipsoidSurface,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 11500.0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchRay.origin&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Theoretically, not with Earth datums, the intersection point can be outside the ellipsoid&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (!defined(rayOrigin)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // intersection point is outside the ellipsoid, try other value&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // minimum height (-11500.0) for the terrain set, need to get this information from the terrain provider&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var minimumHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (defined(tile.data.tileBoundingRegion)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; minimumHeight = tile.data.tileBoundingRegion.minimumHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var magnitude = Math.min(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defaultValue(minimumHeight, 0.0),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; -11500.0&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // multiply by the *positive* value of the magnitude&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var vectorToMinimumPoint = Cartesian3.multiplyByScalar(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceNormal,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Math.abs(magnitude) + 1,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchPosition&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Cartesian3.subtract(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.positionOnEllipsoidSurface,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; vectorToMinimumPoint,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchRay.origin&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Cartographic.clone(data.positionCartographic, scratchCartographic);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // minimum height for the terrain set, need to get this information from the terrain provider&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchCartographic.height = -11500.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; projection.project(scratchCartographic, scratchPosition);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Cartesian3.fromElements(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchPosition.z,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchPosition.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchPosition.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchPosition&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Cartesian3.clone(scratchPosition, scratchRay.origin);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Cartesian3.clone(Cartesian3.UNIT_X, scratchRay.direction);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var position = tile.data.pick(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchRay,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mode,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; projection,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; false,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; scratchPosition&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (defined(position)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.callback(position);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.level = tile.level;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; } else if (tile.level === data.level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var children = tile.children;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var childrenLength = children.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var child;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (var j = 0; j &amp;lt; childrenLength; ++j) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; child = children[j];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (Rectangle.contains(child.rectangle, data.positionCartographic)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var tileDataAvailable = terrainProvider.getTileDataAvailable(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; child.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; child.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; child.level&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var parentTile = tile.parent;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (defined(tileDataAvailable) &amp;amp;&amp;amp; !tileDataAvailable) ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (defined(parentTile) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defined(parentTile.data) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; defined(parentTile.data.terrainData) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !parentTile.data.terrainData.isChildAvailable(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parentTile.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parentTile.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; child.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; child.y&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ))&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data.removeFunc();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (getTimestamp() &amp;gt;= endTime) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; timeSliceMax = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (timeSliceMax) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._lastTileIndex = i;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._lastTileIndex = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tilesToUpdateHeights.shift();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (i = 0; i &amp;lt; tryNextFrame.length; i++) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tilesToUpdateHeights.push(tryNextFrame[i]);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;comic=0;rotatable=0;" parent="zrCMIupTtKye5h8rk7Vh-70" vertex="1">
          <mxGeometry x="886" y="583" width="633" height="2480" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-59" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* Checks if the load queue length has changed since the last time we raised a queue change event - if so, raises&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* a new change event at the end of the render cycle.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;function updateTileLoadProgress(primitive, frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var currentLoadQueueLength =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; primitive._tileLoadQueueHigh.length +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; primitive._tileLoadQueueMedium.length +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; primitive._tileLoadQueueLow.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; currentLoadQueueLength !== primitive._lastTileLoadQueueLength ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; primitive._tilesInvalidated&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.afterRender.push(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Event.prototype.raiseEvent.bind(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileLoadProgressEvent,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; currentLoadQueueLength&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; )&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; primitive._lastTileLoadQueueLength = currentLoadQueueLength;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var debug = primitive._debug;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (debug.enableDebugOutput &amp;amp;&amp;amp; !debug.suspendLodUpdate) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; debug.maxDepth = primitive._tilesToRender.reduce(function (max, tile) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return Math.max(max, tile.level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }, -1);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; debug.tilesRendered = primitive._tilesToRender.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.tilesVisited !== debug.lastTilesVisited ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.tilesRendered !== debug.lastTilesRendered ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.tilesCulled !== debug.lastTilesCulled ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.maxDepth !== debug.lastMaxDepth ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.tilesWaitingForChildren !== debug.lastTilesWaitingForChildren ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.maxDepthVisited !== debug.lastMaxDepthVisited&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; console.log(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;Visited &quot; +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; debug.tilesVisited +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;, Rendered: &quot; +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; debug.tilesRendered +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;, Culled: &quot; +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; debug.tilesCulled +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;, Max Depth Rendered: &quot; +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; debug.maxDepth +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;, Max Depth Visited: &quot; +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; debug.maxDepthVisited +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;, Waiting for children: &quot; +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; debug.tilesWaitingForChildren&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.lastTilesVisited = debug.tilesVisited;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.lastTilesRendered = debug.tilesRendered;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.lastTilesCulled = debug.tilesCulled;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.lastMaxDepth = debug.maxDepth;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.lastTilesWaitingForChildren = debug.tilesWaitingForChildren;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; debug.lastMaxDepthVisited = debug.maxDepthVisited;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;comic=0;rotatable=0;" parent="zrCMIupTtKye5h8rk7Vh-70" vertex="1">
          <mxGeometry x="26" y="2161" width="658" height="898" as="geometry" />
        </mxCell>
        <mxCell id="cho-rxJkQNWqNleOSbak-22" style="orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=2;" parent="zrCMIupTtKye5h8rk7Vh-70" source="_qH6-IZlokEgzrvQ4-RS-48" target="_qH6-IZlokEgzrvQ4-RS-59" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="cho-rxJkQNWqNleOSbak-21" style="orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=2;" parent="zrCMIupTtKye5h8rk7Vh-70" source="_qH6-IZlokEgzrvQ4-RS-47" target="_qH6-IZlokEgzrvQ4-RS-58" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="843" y="-4295" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-57" value="Globe.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=135;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="-567" y="9303" width="616" height="441" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-35" value="&lt;div&gt;&lt;b&gt;Globe.prototype.endFrame = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!this.show) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (frameState.passes.render&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._surface.endFrame(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="zrCMIupTtKye5h8rk7Vh-57" vertex="1">
          <mxGeometry x="161" y="216" width="318" height="142" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-38" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-35" vertex="1">
          <mxGeometry x="177" y="85" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-39" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-35" vertex="1">
          <mxGeometry x="230" y="99" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-1" value="CesiumWidget.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="-4177" y="-625" width="894" height="491" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-9" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Renders the scene.&amp;nbsp; This function is called automatically&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* unless &amp;lt;code&amp;gt;useDefaultRenderLoop&amp;lt;/code&amp;gt; is set to false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;CesiumWidget.prototype.render = function () {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (this._canRender) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._scene.initializeFrame();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var currentTime = this._clock.tick();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._scene.render(currentTime);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._clock.tick();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-1" vertex="1">
          <mxGeometry x="440" y="208" width="394" height="198" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-11" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-9" vertex="1">
          <mxGeometry x="192" y="98" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-18" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;comic=0;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-9" vertex="1">
          <mxGeometry x="212" y="127" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-4" value="Scene.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;resizable=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="-2900" y="-1160" width="2104" height="3169" as="geometry">
            <mxRectangle x="-797" y="-59" width="128" height="40" as="alternateBounds" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-6" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Scene.prototype.initializeFrame = function () {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Destroy released shaders and textures once every 120 frames to avoid thrashing the cache&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;span&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&lt;/b&gt;// 每 120 帧清空 shaderCache 和 textureCache&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (this._shaderFrameCount++ === 120) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._shaderFrameCount = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._context.shaderCache.destroyReleasedShaderPrograms();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._context.textureCache.destroyReleasedTextures();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._tweens.update();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 获取相机高度&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._globeHeight = getGlobeHeight(this);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 判断相机是否在地面以下&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._cameraUnderground = isCameraUnderground(this);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 更新地球透明状态&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._globeTranslucencyState.update(this);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._screenSpaceCameraController.update();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(this._deviceOrientationCameraController)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._deviceOrientationCameraController.update();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 更新相机&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.camera.update(this._mode);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.camera._updateCameraChanged();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" vertex="1">
          <mxGeometry x="11.5" y="135" width="558" height="436" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-17" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Update and render the scene. It is usually not necessary to call this function&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* directly because {@link CesiumWidget} or {@link Viewer} do it automatically.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {JulianDate} [time] The simulation time at which to render.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Scene.prototype.render = function (time) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; /**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* Pre passes update. Execute any pass invariant code that should run before the passes here.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._preUpdate.raiseEvent(this, time);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var frameState = this._frameState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.newFrame = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(time)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; time = JulianDate.now();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Determine if shouldRender&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var cameraChanged = this._view.checkForCameraUpdates(this);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var shouldRender =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !this.requestRenderMode ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._renderRequested ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; cameraChanged ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._logDepthBufferDirty ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._hdrDirty ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this.mode === SceneMode.MORPHING;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !shouldRender &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(this.maximumRenderTimeChange) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(this._lastRenderTime)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var difference = Math.abs(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; JulianDate.secondsDifference(this._lastRenderTime, time)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; shouldRender = shouldRender || difference &amp;gt; this.maximumRenderTimeChange;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (shouldRender) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._lastRenderTime = JulianDate.clone(time, this._lastRenderTime);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._renderRequested = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._logDepthBufferDirty = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._hdrDirty = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var frameNumber = CesiumMath.incrementWrap(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; frameState.frameNumber,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 15000000.0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 1.0&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; updateFrameNumber(this, frameNumber, time);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.newFrame = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tryAndCatchError(this, prePassesUpdate);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; /**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* Passes update. Add any passes here&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (this.primitives.show) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tryAndCatchError(this, updateMostDetailedRayPicks);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 更新 Camera、CullingVolume、Primitives 和 3dtiles 相关内容&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tryAndCatchError(this, updatePreloadPass);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tryAndCatchError(this, updatePreloadFlightPass);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!shouldRender) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tryAndCatchError(this, updateRequestRenderModeDeferCheckPass);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._postUpdate.raiseEvent(this, time);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (shouldRender) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._preRender.raiseEvent(this, time);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.creditDisplay.beginFrame();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tryAndCatchError(this, render);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; /**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* Post passes update. Execute any pass invariant code that should run after the passes here.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; updateDebugShowFramesPerSecond(this, shouldRender);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tryAndCatchError(this, postPassesUpdate);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Often used to trigger events (so don&#39;t want in trycatch) that the user might be subscribed to.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Things like the tile load events, ready promises, etc.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // We don&#39;t want those events to resolve during the render loop because the events might add&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // new primitives&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; callAfterRenderFunctions(this);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (shouldRender) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._postRender.raiseEvent(this, time);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.creditDisplay.endFrame();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" vertex="1">
          <mxGeometry x="11.5" y="773" width="566" height="1405" as="geometry">
            <mxRectangle x="-892" y="427" width="882" height="1360" as="alternateBounds" />
          </mxGeometry>
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-2" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-17" vertex="1">
          <mxGeometry x="262.5" y="786.004553314121" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-42" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="_qH6-IZlokEgzrvQ4-RS-17" vertex="1">
          <mxGeometry x="205.5" y="1093.0031700288184" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-1" value="&lt;div&gt;&lt;b&gt;function prePassesUpdate(scene) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene._jobScheduler.resetBudgets();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var frameState = scene._frameState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var primitives = scene.primitives;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitives.prePassesUpdate(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(scene.globe)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; scene.globe.update(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene._picking.update();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.creditDisplay.update();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" vertex="1">
          <mxGeometry x="677" y="697" width="263" height="212" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-5" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-1" vertex="1">
          <mxGeometry x="209" y="127" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-3" style="orthogonalLoop=1;jettySize=auto;html=1;jumpStyle=none;sketch=0;rounded=1;edgeStyle=orthogonalEdgeStyle;shadow=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" source="xKLGjb7A9fxTzqLFo98r-2" target="xKLGjb7A9fxTzqLFo98r-1" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="616" y="1563" />
              <mxPoint x="616" y="716" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-43" value="&lt;span&gt;&lt;b&gt;function render(scene) {&lt;/b&gt;&lt;/span&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var frameState = scene._frameState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var context = scene.context;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var us = context.uniformState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var view = scene._defaultView;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene._view = view;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene.updateFrameState();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.passes.render = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.passes.postProcess = scene.postProcessStages.hasSelected;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.tilesetPassState = renderTilesetPassState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var backgroundColor = defaultValue(scene.backgroundColor, Color.BLACK);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (scene._hdr) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; backgroundColor = Color.clone(backgroundColor, scratchBackgroundColor);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; backgroundColor.red = Math.pow(backgroundColor.red, scene.gamma);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; backgroundColor.green = Math.pow(backgroundColor.green, scene.gamma);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; backgroundColor.blue = Math.pow(backgroundColor.blue, scene.gamma);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.backgroundColor = backgroundColor;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene.fog.update(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;b&gt;&amp;nbsp; // 更新 UniformState，UniformState 更新所需的信息都来源于 FrameState&lt;/b&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; us.update(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var shadowMap = scene.shadowMap;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(shadowMap) &amp;amp;&amp;amp; shadowMap.enabled) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!defined(scene.light) || scene.light instanceof SunLight) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Negate the sun direction so that it is from the Sun, not to the Sun&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Cartesian3.negate(us.sunDirectionWC, scene._shadowMapCamera.direction);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Cartesian3.clone(scene.light.direction, scene._shadowMapCamera.direction);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.shadowMaps.push(shadowMap);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 清空 _computeCommandList&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene._computeCommandList.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 清空 _overlayCommandList&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene._overlayCommandList.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 更新 viewport&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var viewport = view.viewport;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; viewport.x = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; viewport.y = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; viewport.width = context.drawingBufferWidth;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; viewport.height = context.drawingBufferHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 更新 passState&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var passState = view.passState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 清空 FBO&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; passState.framebuffer = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; passState.blendingEnabled = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; passState.scissorTest = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; passState.viewport = BoundingRectangle.clone(viewport, passState.viewport);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(scene.globe)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; scene.globe.beginFrame(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 更新环境、天空球、前后剪切面相关&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene.updateEnvironment();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 更新 passState.framebuffer，并对该 FBO 渲染&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene.updateAndExecuteCommands(passState, backgroundColor);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 处理FBO，并渲染到屏幕中&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene.resolveFramebuffers(passState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; passState.framebuffer = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; executeOverlayCommands(scene, passState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(scene.globe)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; scene.globe.endFrame(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!scene.globe.tilesLoaded) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; scene._renderRequested = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; context.endFrame();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" vertex="1">
          <mxGeometry x="679" y="1065" width="481" height="1199" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-48" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-43" vertex="1">
          <mxGeometry x="172" y="140.99913484153575" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-50" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-43" vertex="1">
          <mxGeometry x="239" y="869.0034147776875" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-3" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="xKLGjb7A9fxTzqLFo98r-43" vertex="1">
          <mxGeometry x="3" y="953" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-55" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="xKLGjb7A9fxTzqLFo98r-43">
          <mxGeometry x="231" y="1066" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-46" value="&lt;div&gt;&lt;b&gt;Scene.prototype.updateFrameState = function () {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var camera = this.camera;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var frameState = this._frameState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.commandList.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.shadowMaps.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.brdfLutGenerator = this._brdfLutGenerator;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.environmentMap = this.skyBox &amp;amp;&amp;amp; this.skyBox._cubeMap;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.mode = this._mode;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.morphTime = this.morphTime;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.mapProjection = this.mapProjection;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.camera = camera;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.cullingVolume = camera.frustum.computeCullingVolume(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; camera.positionWC,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; camera.directionWC,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; camera.upWC&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.occluder = getOccluder(this);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.terrainExaggeration = this._terrainExaggeration;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.minimumTerrainHeight = 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.minimumDisableDepthTestDistance = this._minimumDisableDepthTestDistance;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.invertClassification = this.invertClassification;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.useLogDepth =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._logDepthBuffer &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this.camera.frustum instanceof OrthographicFrustum ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this.camera.frustum instanceof OrthographicOffCenterFrustum&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.light = this.light;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.cameraUnderground = this._cameraUnderground;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.globeTranslucencyState = this._globeTranslucencyState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(this._specularEnvironmentMapAtlas) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._specularEnvironmentMapAtlas.ready&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.specularEnvironmentMaps = this._specularEnvironmentMapAtlas.texture;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.specularEnvironmentMapsMaximumLOD = this._specularEnvironmentMapAtlas.maximumMipmapLevel;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.specularEnvironmentMaps = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.specularEnvironmentMapsMaximumLOD = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.sphericalHarmonicCoefficients = this.sphericalHarmonicCoefficients;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._actualInvertClassificationColor = Color.clone(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this.invertClassificationColor,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._actualInvertClassificationColor&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!InvertClassification.isTranslucencySupported(this._context)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._actualInvertClassificationColor.alpha = 1.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.invertClassificationColor = this._actualInvertClassificationColor;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(this.globe)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.maximumScreenSpaceError = this.globe.maximumScreenSpaceError;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.maximumScreenSpaceError = 2;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.clearPasses(frameState.passes);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState.tilesetPassState = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" vertex="1">
          <mxGeometry x="1202" y="849" width="695" height="926" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-47" style="orthogonalLoop=1;jettySize=auto;html=1;sketch=0;edgeStyle=orthogonalEdgeStyle;" parent="_qH6-IZlokEgzrvQ4-RS-4" source="xKLGjb7A9fxTzqLFo98r-42" target="xKLGjb7A9fxTzqLFo98r-43" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="554" y="1870" />
              <mxPoint x="554" y="1870" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-49" style="orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;" parent="_qH6-IZlokEgzrvQ4-RS-4" source="xKLGjb7A9fxTzqLFo98r-48" target="xKLGjb7A9fxTzqLFo98r-46" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="787" y="1210" as="sourcePoint" />
            <Array as="points">
              <mxPoint x="1047" y="1210" />
              <mxPoint x="1047" y="1210" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-2" value="&lt;div&gt;&lt;b&gt;Scene.prototype.updateAndExecuteCommands = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; passState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; backgroundColor&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var frameState = this._frameState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var mode = frameState.mode;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var useWebVR = this._environmentState.useWebVR;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (useWebVR) {&amp;nbsp; // 用于 WebVR&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; executeWebVRCommands(this, passState, backgroundColor);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; mode !== SceneMode.SCENE2D ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._mapMode2D === MapMode2D.ROTATE&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&amp;nbsp; // 一般情况&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; executeCommandsInViewport(true, this, passState, backgroundColor);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&amp;nbsp; // 用于 2D 模式&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; updateAndClearFramebuffers(this, passState, backgroundColor);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; execute2DViewportCommands(this, passState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" vertex="1">
          <mxGeometry x="679" y="2307" width="439" height="296" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-6" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="_K7aeOZNzX8ZAruB3Fqv-2" vertex="1">
          <mxGeometry x="425" y="211" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-4" style="orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;arcSize=50;" parent="_qH6-IZlokEgzrvQ4-RS-4" source="_K7aeOZNzX8ZAruB3Fqv-3" target="_K7aeOZNzX8ZAruB3Fqv-2" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="1093" y="1874" as="targetPoint" />
            <Array as="points">
              <mxPoint x="648" y="2022" />
              <mxPoint x="648" y="2329" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-5" value="&lt;div&gt;&lt;b&gt;function executeCommandsInViewport(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; firstViewport,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; passState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; backgroundColor&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var environmentState = scene._environmentState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var view = scene._view;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var renderTranslucentDepthForPick =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; environmentState.renderTranslucentDepthForPick;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!firstViewport &amp;amp;&amp;amp; !renderTranslucentDepthForPick) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; scene.frameState.commandList.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!renderTranslucentDepthForPick) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; updateAndRenderPrimitives(scene);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; view.createPotentiallyVisibleSet(scene);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (firstViewport) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(backgroundColor)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; updateAndClearFramebuffers(scene, passState, backgroundColor);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!renderTranslucentDepthForPick) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; executeComputeCommands(scene);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; executeShadowMapCastCommands(scene);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; executeCommands(scene, passState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" vertex="1">
          <mxGeometry x="1181" y="2307" width="427" height="478" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-29" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="_K7aeOZNzX8ZAruB3Fqv-5" vertex="1">
          <mxGeometry x="233" y="239" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-28" value="&lt;div&gt;&lt;b&gt;function updateAndRenderPrimitives(scene) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var frameState = scene._frameState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene._groundPrimitives.update(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; scene._primitives.update(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; updateDebugFrustumPlanes(scene);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; updateShadowMaps(scene);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (scene._globe) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; scene._globe.render(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-4" vertex="1">
          <mxGeometry x="1779" y="2438" width="288" height="198" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-34" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-28" vertex="1">
          <mxGeometry x="215.5" y="155" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-31" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;" parent="_qH6-IZlokEgzrvQ4-RS-4" source="_K7aeOZNzX8ZAruB3Fqv-29" target="_K7aeOZNzX8ZAruB3Fqv-28" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-7" style="orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;" parent="_qH6-IZlokEgzrvQ4-RS-4" source="_K7aeOZNzX8ZAruB3Fqv-6" target="_K7aeOZNzX8ZAruB3Fqv-5" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="1560" y="2405" as="sourcePoint" />
            <Array as="points">
              <mxPoint x="1160" y="2522" />
              <mxPoint x="1160" y="2522" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-16" style="orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#000000;edgeStyle=orthogonalEdgeStyle;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-11" target="_qH6-IZlokEgzrvQ4-RS-6" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="-3046" y="-315" />
              <mxPoint x="-3046" y="-962" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-23" value="FrameState" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="-640" y="9973" width="692" height="306" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-27" value="&lt;div&gt;&lt;b&gt;this.passes = {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; render: false,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; pick: false,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; depth: false,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; postProcess: false,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; offscreen: false,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;collapsible=0;comic=0;rotatable=0;fillColor=#FFD966;" parent="_qH6-IZlokEgzrvQ4-RS-23" vertex="1">
          <mxGeometry x="14" y="172" width="139" height="114" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-29" value="&lt;div&gt;&lt;b&gt;this.mode = SceneMode.SCENE3D;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;// SceneMode 包含以下类型&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;var SceneMode = {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; MORPHING: 0, // Morphing between mode, e.g., 3D to 2D.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; COLUMBUS_VIEW: 1, // Columbus View mode.&amp;nbsp; A 2.5D perspective view&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; SCENE2D: 2,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; SCENE3D: 3,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;collapsible=0;comic=0;rotatable=0;fillColor=#FFD966;" parent="_qH6-IZlokEgzrvQ4-RS-23" vertex="1">
          <mxGeometry x="242" y="163" width="436" height="128" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-34" value="Globe.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=135;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="-549" y="-589" width="616" height="2165" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-4" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;Globe.prototype.update = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!this.show) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (frameState.passes.render) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._surface.update(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-34" vertex="1">
          <mxGeometry x="70" y="156" width="300" height="184" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-8" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-4" vertex="1">
          <mxGeometry x="212" y="141.00000000000006" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-51" value="&lt;div&gt;&lt;b&gt;Globe.prototype.beginFrame = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surface = this._surface;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileProvider = surface.tileProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainProvider = this.terrainProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var hasWaterMask =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this.showWaterEffect &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainProvider.ready &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainProvider.hasWaterMask;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 处理海洋的 NormalMap&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (hasWaterMask &amp;amp;&amp;amp; this._oceanNormalMapResourceDirty) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // url changed, load new normal map asynchronously&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._oceanNormalMapResourceDirty = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var oceanNormalMapResource = this._oceanNormalMapResource;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var oceanNormalMapUrl = oceanNormalMapResource.url;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(oceanNormalMapUrl)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var that = this;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; when(oceanNormalMapResource.fetchImage(), function (image) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (oceanNormalMapUrl !== that._oceanNormalMapResource.url) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // url changed while we were loading&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; that._oceanNormalMap =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; that._oceanNormalMap &amp;amp;&amp;amp; that._oceanNormalMap.destroy();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; that._oceanNormalMap = new Texture({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; context: frameState.context,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; source: image,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this._oceanNormalMap =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; this._oceanNormalMap &amp;amp;&amp;amp; this._oceanNormalMap.destroy();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var pass = frameState.passes;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var mode = frameState.mode;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (pass.render) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (this.showGroundAtmosphere) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this._zoomedOutOceanSpecularIntensity = 0.4;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this._zoomedOutOceanSpecularIntensity = 0.5;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 对 QuadtreePrimitive 中的变量进行赋值&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surface.maximumScreenSpaceError = this.maximumScreenSpaceError;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surface.tileCacheSize = this.tileCacheSize;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surface.loadingDescendantLimit = this.loadingDescendantLimit;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surface.preloadAncestors = this.preloadAncestors;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surface.preloadSiblings = this.preloadSiblings;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 对 GlobeSurfaceTileProvider 中的变量进行赋值&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.terrainProvider = this.terrainProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.lightingFadeOutDistance = this.lightingFadeOutDistance;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.lightingFadeInDistance = this.lightingFadeInDistance;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.nightFadeOutDistance = this.nightFadeOutDistance;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.nightFadeInDistance = this.nightFadeInDistance;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.zoomedOutOceanSpecularIntensity =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; mode === SceneMode.SCENE3D ? this._zoomedOutOceanSpecularIntensity : 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.hasWaterMask = hasWaterMask;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.oceanNormalMap = this._oceanNormalMap;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.enableLighting = this.enableLighting;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.dynamicAtmosphereLighting = this.dynamicAtmosphereLighting;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.dynamicAtmosphereLightingFromSun = this.dynamicAtmosphereLightingFromSun;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.showGroundAtmosphere = this.showGroundAtmosphere;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.shadows = this.shadows;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.hueShift = this.atmosphereHueShift;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.saturationShift = this.atmosphereSaturationShift;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.brightnessShift = this.atmosphereBrightnessShift;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.fillHighlightColor = this.fillHighlightColor;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.showSkirts = this.showSkirts;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.backFaceCulling = this.backFaceCulling;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.undergroundColor = this._undergroundColor;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.undergroundColorAlphaByDistance = this._undergroundColorAlphaByDistance;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surface.beginFrame(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-34" vertex="1">
          <mxGeometry x="14" y="540" width="584" height="1136" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-55" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-51" vertex="1">
          <mxGeometry x="212" y="1093" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-32" value="&lt;div&gt;&lt;b&gt;Globe.prototype.render = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!this.show) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(this._material)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._material.update(frameState.context);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._surface.render(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-34" vertex="1">
          <mxGeometry x="154" y="1903" width="298" height="170" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-37" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-32" vertex="1">
          <mxGeometry x="208" y="141" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="cho-rxJkQNWqNleOSbak-7" style="orthogonalLoop=1;jettySize=auto;html=1;elbow=vertical;strokeWidth=2;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-39" target="_qH6-IZlokEgzrvQ4-RS-41" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="282.4" y="470.69999999999993" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-40" value="QuadtreePrimitive.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=135;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="321" y="-542" width="2931" height="8362" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-7" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Updates the tile provider imagery and continues to process the tile load queue.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;QuadtreePrimitive.prototype.update = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(this._tileProvider.update)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._tileProvider.update(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="26" y="161" width="484" height="142" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-34" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-7" vertex="1">
          <mxGeometry x="238" y="99.00000000000006" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-54" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Initializes values for a new render frame and prepare the tile load queue.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;QuadtreePrimitive.prototype.beginFrame = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var passes = frameState.passes;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!passes.render) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 清理所有瓦片&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 正常情况下 this._tilesInvalidated 为 false&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (this._tilesInvalidated) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; invalidateAllTiles(this);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._tilesInvalidated = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Gets commands for any texture re-projections&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._tileProvider.initialize(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; clearTileLoadQueue(this);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (this._debug.suspendLodUpdate) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._tileReplacementQueue.markStartOfRenderFrame();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="30" y="443" width="445" height="408" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-58" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-54" vertex="1">
          <mxGeometry x="240" y="267" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-134" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;sketch=0;fontSize=75;align=center;" parent="xKLGjb7A9fxTzqLFo98r-54" vertex="1">
          <mxGeometry x="341" y="379" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-36" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Selects new tiles to load based on the frame state and creates render commands.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;QuadtreePrimitive.prototype.render = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var passes = frameState.passes;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileProvider = this._tileProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (passes.render) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.beginUpdate(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; selectTilesForRendering(this, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; createRenderCommandsForSelectedTiles(this, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.endUpdate(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (passes.pick &amp;amp;&amp;amp; this._tilesToRender.length &amp;gt; 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.updateForPick(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="160" y="1115" width="498" height="310" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-40" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-36" vertex="1">
          <mxGeometry x="239" y="140" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-43" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-36" vertex="1">
          <mxGeometry x="265" y="169" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-47" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="_K7aeOZNzX8ZAruB3Fqv-36">
          <mxGeometry x="363" y="183" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-53" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="_K7aeOZNzX8ZAruB3Fqv-36">
          <mxGeometry x="231" y="210" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-42" value="&lt;div&gt;&lt;b&gt;function selectTilesForRendering(primitive, frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var debug = primitive._debug;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (debug.suspendLodUpdate) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 清理 render list.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tilesToRender = primitive._tilesToRender;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tilesToRender.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 在渲染前需要创建 level 0 瓦片&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // We can&#39;t render anything before the level zero tiles exist.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var i;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileProvider = primitive._tileProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(primitive._levelZeroTiles)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (tileProvider.ready) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var tilingScheme = tileProvider.tilingScheme;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._levelZeroTiles = QuadtreeTile.createLevelZeroTiles(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tilingScheme&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var numberOfRootTiles = primitive._levelZeroTiles.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (rootTraversalDetails.length &amp;lt; numberOfRootTiles) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 使 rootTraversalDetails 数组的大小不小于 _levelZeroTiles 数组的大小&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rootTraversalDetails = new Array(numberOfRootTiles);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (i = 0; i &amp;lt; numberOfRootTiles; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (rootTraversalDetails[i] === undefined) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rootTraversalDetails[i] = new TraversalDetails();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Nothing to do until the provider is ready.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive._occluders.ellipsoid.cameraPosition = frameState.camera.positionWC;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tile;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var levelZeroTiles = primitive._levelZeroTiles;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var occluders = levelZeroTiles.length &amp;gt; 1 ? primitive._occluders : undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 将 0 级瓦片按照瓦片中心到摄像机的距离及进行排序。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 算法的思路是比较经度差和纬度差的平方和，相当于只考虑平面，没有考虑高度方向&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // The level zero tiles aren&#39;t necessarily a nice neat quad, so we can&#39;t use the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // quadtree ordering we use elsewhere in the tree&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; comparisonPoint = frameState.camera.positionCartographic;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; levelZeroTiles.sort(compareDistanceToPoint);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var customDataAdded = primitive._addHeightCallbacks;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var customDataRemoved = primitive._removeHeightCallbacks;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var frameNumber = frameState.frameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var len;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (customDataAdded.length &amp;gt; 0 || customDataRemoved.length &amp;gt; 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (i = 0, len = levelZeroTiles.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile = levelZeroTiles[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile._updateCustomData(frameNumber, customDataAdded, customDataRemoved);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; customDataAdded.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; customDataRemoved.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var camera = frameState.camera;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive._cameraPositionCartographic = camera.positionCartographic;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var cameraFrameOrigin = Matrix4.getTranslation(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; camera.transform,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; cameraOriginScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive._cameraReferenceFrameOriginCartographic = primitive.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; cameraFrameOrigin,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; primitive._cameraReferenceFrameOriginCartographic&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Traverse in depth-first, near-to-far order.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 按深度优先，从近至远&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (i = 0, len = levelZeroTiles.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile = levelZeroTiles[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; primitive._tileReplacementQueue.markTileRendered(tile); // 0 级瓦片标记为渲染&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!tile.renderable) { // 如果不可渲染&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // 在 _tileLoadQueueHigh 中对 0 级瓦片加载优先级进行排序并添加至队列&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ++debug.tilesWaitingForChildren;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;false,&amp;nbsp;&lt;/b&gt;&lt;b&gt;rootTraversalDetails[i]&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive._lastSelectionFrameNumber = frameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="232" y="1671" width="746" height="1307" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-49" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-42" vertex="1">
          <mxGeometry x="160" y="127.00432461873635" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-53" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-42" vertex="1">
          <mxGeometry x="383" y="252.0041849256003" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-59" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-42" vertex="1">
          <mxGeometry x="349" y="336.9959118519243" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-87" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-42" vertex="1">
          <mxGeometry x="473" y="1132.9957733428369" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-139" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-42" vertex="1">
          <mxGeometry x="453" y="1176.0048111190306" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-220" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;sketch=0;fontSize=75;align=center;" parent="_K7aeOZNzX8ZAruB3Fqv-42" vertex="1">
          <mxGeometry x="12" y="1219.0039344262293" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-138" value="&lt;div&gt;&lt;b&gt;function queueTileLoad(primitive, queue, tile, frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!tile.needsLoading) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (primitive.tileProvider.computeTileLoadPriority !== undefined) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile._loadPriority = primitive.tileProvider.computeTileLoadPriority(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; frameState&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; queue.push(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="1956" y="3700" width="410" height="198" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-1" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="_K7aeOZNzX8ZAruB3Fqv-138" vertex="1">
          <mxGeometry x="397" y="100" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-219" value="&lt;div&gt;&lt;b&gt;function visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;traversalDetails&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;b&gt;tileProvider.computeTileVisibility(tile, frameState, occluders) !==&amp;nbsp;&lt;/b&gt;&lt;b&gt;Visibility.NONE&lt;/b&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return visitTile(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;traversalDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ++primitive._debug.tilesCulled;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive._tileReplacementQueue.markTileRendered(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; traversalDetails.allAreRenderable = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; traversalDetails.anyWereRenderedLastFrame = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; traversalDetails.notYetRenderableCount = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (containsNeededPosition(primitive, tile)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Load the tile(s) that contains the camera&#39;s position and&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // the origin of its reference frame with medium priority.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // But we only need to load until the terrain is available, no need to load imagery.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!defined(tile.data) || !defined(tile.data.vertexArray)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; queueTileLoad(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;primitive._tileLoadQueueMedium,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var lastFrame = primitive._lastSelectionFrameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var lastFrameSelectionResult =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile._lastSelectionResultFrame === lastFrame&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ? tile._lastSelectionResult&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : TileSelectionResult.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; lastFrameSelectionResult !== TileSelectionResult.CULLED_BUT_NEEDED &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; lastFrameSelectionResult !== TileSelectionResult.RENDERED&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileToUpdateHeights.push(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile._lastSelectionResult = TileSelectionResult.CULLED_BUT_NEEDED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else if (primitive.preloadSiblings || tile.level === 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Load culled level zero tiles with low priority.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // For all other levels, only load culled tiles if preloadSiblings is enabled.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile._lastSelectionResult = TileSelectionResult.CULLED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile._lastSelectionResult = TileSelectionResult.CULLED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile._lastSelectionResultFrame = frameState.frameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="235" y="3103" width="511" height="665" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-21" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="_K7aeOZNzX8ZAruB3Fqv-219" vertex="1">
          <mxGeometry x="498.9989024390244" y="57.00140186915888" width="7.252336448598131" height="7.252336448598131" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-24" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="_K7aeOZNzX8ZAruB3Fqv-219" vertex="1">
          <mxGeometry x="7.001097560975609" y="71.00271028037383" width="7.252336448598131" height="7.252336448598131" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-35" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="_K7aeOZNzX8ZAruB3Fqv-219">
          <mxGeometry x="344" y="126" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-37" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="_K7aeOZNzX8ZAruB3Fqv-219">
          <mxGeometry x="267" y="210" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-41" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="_K7aeOZNzX8ZAruB3Fqv-219">
          <mxGeometry x="467" y="281" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-44" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="_K7aeOZNzX8ZAruB3Fqv-219">
          <mxGeometry x="435" y="545" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-221" style="edgeStyle=orthogonalEdgeStyle;rounded=1;sketch=0;jumpStyle=none;orthogonalLoop=1;jettySize=auto;html=1;fontSize=75;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="_K7aeOZNzX8ZAruB3Fqv-220" target="_K7aeOZNzX8ZAruB3Fqv-219" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="141" y="2894" />
              <mxPoint x="141" y="3120" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-23" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Visits a tile for possible rendering. When we call this function with a tile:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; * the tile has been determined to be visible (possibly based on a bounding volume that is not very tight-fitting)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; * its parent tile does _not_ meet the SSE (unless ancestorMeetsSse=true, see comments below)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; * the tile may or may not be renderable&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Primitive} primitive The QuadtreePrimitive.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The frame state.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {QuadtreeTile} tile The tile to visit&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Boolean} ancestorMeetsSse True if a tile higher in the tile tree already met the SSE and we&#39;re refining further only&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; to maintain detail while that higher tile loads.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TraversalDetails} traveralDetails On return, populated with details of how the traversal of this tile went.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;function visitTile(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;traversalDetails&lt;/b&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var debug = primitive._debug;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ++debug.tilesVisited;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive._tileReplacementQueue.markTileRendered(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile._updateCustomData(frameState.frameNumber);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (tile.level &amp;gt; debug.maxDepthVisited) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; debug.maxDepthVisited = tile.level;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 距离越近，计算出的 error 越大。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // meetsSse 为 false 表示计算出的 error 过大，瓦片距离相机太近，可以渲染更精细层级的瓦片了&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var meetsSse =&amp;nbsp;&lt;/b&gt;&lt;b&gt;screenSpaceError(primitive, frameState, tile) &amp;lt;&amp;nbsp;&lt;/b&gt;&lt;b&gt;primitive.maximumScreenSpaceError;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var southwestChild = tile.southwestChild;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var southeastChild = tile.southeastChild;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var northwestChild = tile.northwestChild;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var northeastChild = tile.northeastChild;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var lastFrame = primitive._lastSelectionFrameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var lastFrameSelectionResult =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile._lastSelectionResultFrame === lastFrame // 判断瓦片上一帧是否被选择&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ? tile._lastSelectionResult&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; : TileSelectionResult.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileProvider = primitive.tileProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (meetsSse || ancestorMeetsSse) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 我们想要在这一帧渲染该瓦片（或其父瓦片），但我们会根据该瓦片的状态和我们上一帧所做的事情来做不同的事情&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 达到以下 任何 条件，我们就可以渲染该瓦片：&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 1. 我们在上一帧渲染过它（或 kicked it)。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 2. 该瓦片在上一帧被 culled，或者其父级被 culled，导致其不可见。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 3. 该瓦片加载完毕。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 4. a) 地形准备完毕，并且&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; //&amp;nbsp; &amp;nbsp; &amp;nbsp;b) 所有必须的影像准备完毕。必须的影像指该瓦片的影像或&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; //&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 任何子瓦片的影像。这些影像是必须的，这些影像的缺失会导致该瓦片的的渲染缺失细节&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; //&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 条件 4 的计算比较昂贵，因此先检查其他条件。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; //&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 注意，即使我们在此处决定渲染该瓦片，它有可能为了父级而被剔除掉。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var oneRenderedLastFrame =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; TileSelectionResult.originalResult(lastFrameSelectionResult) ===&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var twoCulledOrNotVisited =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; TileSelectionResult.originalResult(lastFrameSelectionResult) ===&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; TileSelectionResult.CULLED ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; lastFrameSelectionResult === TileSelectionResult.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var threeCompletelyLoaded = tile.state === QuadtreeTileLoadState.DONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var renderable =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; oneRenderedLastFrame || twoCulledOrNotVisited || threeCompletelyLoaded;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!renderable) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Check the more expensive condition 4 above. This requires details of the thing&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // we&#39;re rendering (e.g. the globe surface), so delegate it to the tile provider.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (defined(tileProvider.canRenderWithoutLosingDetail)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; renderable = tileProvider.canRenderWithoutLosingDetail(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (renderable) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Only load this tile if it (not just an ancestor) meets the SSE.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (meetsSse) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 此处是添加至中等优先队列&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; queueTileLoad(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;primitive._tileLoadQueueMedium,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; addTileToRenderList(primitive, tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.allAreRenderable = tile.renderable;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.anyWereRenderedLastFrame =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; lastFrameSelectionResult === TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile._lastSelectionResultFrame = frameState.frameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile._lastSelectionResult = TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (!traversalDetails.anyWereRenderedLastFrame) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 瓦片在上一帧没有渲染，则将其添加至高度更新队列&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileToUpdateHeights.push(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Otherwise, we can&#39;t render this tile (or its fill) because doing so would cause detail to disappear&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // that was visible last frame. Instead, keep rendering any still-visible descendants that were rendered&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // last frame and render fills for newly-visible descendants. 例如，如果上一帧我们渲染了 level 15，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 但这一帧我们要渲染 level 14，&amp;lt;=14 的最大可渲染级别是 0，渲染 0 级瓦片是不合适的，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 因此我们仍然渲染 15 级，即使它的 SSE 高于需求。So fall through to continue traversal...&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ancestorMeetsSse = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Load this blocker tile with high priority, but only if this tile (not just an ancestor) meets the SSE.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (meetsSse) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (tileProvider.canRefine(tile)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var allAreUpsampled =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; southwestChild.upsampledFromParent &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; southeastChild.upsampledFromParent &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; northwestChild.upsampledFromParent &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; northeastChild.upsampledFromParent;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (allAreUpsampled) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // No point in rendering the children because they&#39;re all upsampled.&amp;nbsp; Render this tile instead.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; addTileToRenderList(primitive, tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Rendered tile that&#39;s not waiting on children loads with medium priority.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; queueTileLoad(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;primitive._tileLoadQueueMedium,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Make sure we don&#39;t unload the children and forget they&#39;re upsampled.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileReplacementQueue.markTileRendered(southwestChild);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileReplacementQueue.markTileRendered(southeastChild);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileReplacementQueue.markTileRendered(northwestChild);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileReplacementQueue.markTileRendered(northeastChild);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.allAreRenderable = tile.renderable;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.anyWereRenderedLastFrame =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; lastFrameSelectionResult === TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile._lastSelectionResultFrame = frameState.frameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile._lastSelectionResult = TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (!traversalDetails.anyWereRenderedLastFrame) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 瓦片在上一帧没有渲染，则将其添加至高度更新队列&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileToUpdateHeights.push(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // SSE is not good enough, so refine.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile._lastSelectionResultFrame = frameState.frameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile._lastSelectionResult = TileSelectionResult.REFINED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var firstRenderedDescendantIndex = primitive._tilesToRender.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var loadIndexLow = primitive._tileLoadQueueLow.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var loadIndexMedium = primitive._tileLoadQueueMedium.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var loadIndexHigh = primitive._tileLoadQueueHigh.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var tilesToUpdateHeightsIndex = primitive._tileToUpdateHeights.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // No need to add the children to the load queue because they&#39;ll be added (if necessary) when they&#39;re visited.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitVisibleChildrenNearToFar(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; primitive,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; southwestChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; southeastChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; northwestChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; northeastChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; frameState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ancestorMeetsSse,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 如果上面的函数没有将任何子瓦片添加至渲染列表中，表明他们全部, it means they were all&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 被 culled 了，even though this tile was deemed visible. That&#39;s pretty common.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (firstRenderedDescendantIndex !== primitive._tilesToRender.length) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // 至少有一个子瓦片被添加至渲染列表中。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // The traversalDetails tell us what happened while visiting the children.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var allAreRenderable = traversalDetails.allAreRenderable;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var anyWereRenderedLastFrame = traversalDetails.anyWereRenderedLastFrame;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var notYetRenderableCount = traversalDetails.notYetRenderableCount;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var queuedForLoad = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (!allAreRenderable &amp;amp;&amp;amp; !anyWereRenderedLastFrame) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 某些子瓦片还没准备好，没有任何子瓦片在上一帧被渲染，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 因此将他们全部剔除出渲染列表，渲染当前瓦片，等待继续加载。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 将已经添加至渲染列表和它们的父级（直到当前瓦片）标记为 kicked&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var renderList = primitive._tilesToRender;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (var i = firstRenderedDescendantIndex; i &amp;lt; renderList.length; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var workTile = renderList[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; while (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; workTile !== undefined &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; workTile._lastSelectionResult !== TileSelectionResult.KICKED &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; workTile !== tile&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; workTile._lastSelectionResult = TileSelectionResult.kick(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; workTile._lastSelectionResult&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; workTile = workTile.parent;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 将所有子瓦片从渲染泪飙中移除，添加当前瓦片&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tilesToRender.length = firstRenderedDescendantIndex;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileToUpdateHeights.length = tilesToUpdateHeightsIndex;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; addTileToRenderList(primitive, tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tile._lastSelectionResult = TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 如果我们在等待大量子瓦片，上面的过程会耗费过多时间。在这种情况下，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 选择加载当前瓦片而不是它的子瓦片，告知上级瓦片我们仅仅在等待当前瓦片。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 持续操作直到我们可以渲染当前瓦片。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var wasRenderedLastFrame =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; lastFrameSelectionResult === TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;b&gt;!wasRenderedLastFrame &amp;amp;&amp;amp;&amp;nbsp;&lt;/b&gt;&lt;b&gt;notYetRenderableCount &amp;gt; primitive.loadingDescendantLimit&lt;/b&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 将所有子瓦片移除出加载队列&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileLoadQueueLow.length = loadIndexLow;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileLoadQueueMedium.length = loadIndexMedium;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileLoadQueueHigh.length = loadIndexHigh;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; queueTileLoad(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;primitive._tileLoadQueueMedium,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; queuedForLoad = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.allAreRenderable = tile.renderable;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; traversalDetails.anyWereRenderedLastFrame = wasRenderedLastFrame;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (!wasRenderedLastFrame) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 瓦片是这一真新渲染的，将其添加至高度更新列表&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._tileToUpdateHeights.push(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ++debug.tilesWaitingForChildren;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (primitive.preloadAncestors &amp;amp;&amp;amp; !queuedForLoad) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; queueTileLoad(primitive, primitive._tileLoadQueueLow, tile, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile._lastSelectionResultFrame = frameState.frameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile._lastSelectionResult = TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 我们想要细化，但缺少子瓦片的数据，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 因此我们不知道细化是否会引发加载或者 upsample。我们需要先加载完成当前瓦片，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 因此将该瓦片采用高优先级加载。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; addTileToRenderList(primitive, tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; queueTileLoad(primitive, primitive._tileLoadQueueHigh, tile, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; traversalDetails.allAreRenderable = tile.renderable;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; traversalDetails.anyWereRenderedLastFrame =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; lastFrameSelectionResult === TileSelectionResult.RENDERED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; traversalDetails.notYetRenderableCount = tile.renderable ? 0 : 1;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;comic=0;rotatable=0;snapToPoint=0;recursiveResize=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="235" y="3808" width="735" height="3688" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-29" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="347" y="308" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-32" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="311" y="322" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-36" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="594" y="435" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-68" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="390" y="1079" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-70" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="469" y="1190" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-132" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="234" y="1218" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-134" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="445" y="1596" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-138" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="196" y="1653" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-144" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="236" y="1779" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-146" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="465" y="1821" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-148" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="429" y="1882" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-153" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="7" y="2311" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-157" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-23" vertex="1">
          <mxGeometry x="244" y="2954" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-1" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" vertex="1" parent="O9qtJ-ZTzyiBhBGTBMVZ-23">
          <mxGeometry x="479" y="3150" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-3" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" vertex="1" parent="O9qtJ-ZTzyiBhBGTBMVZ-23">
          <mxGeometry x="453" y="3388" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-21" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="O9qtJ-ZTzyiBhBGTBMVZ-23">
          <mxGeometry x="223" y="3570" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-25" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="O9qtJ-ZTzyiBhBGTBMVZ-23">
          <mxGeometry x="440" y="3585" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-25" style="edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-24" target="O9qtJ-ZTzyiBhBGTBMVZ-23" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="190" y="3178" />
              <mxPoint x="190" y="4052" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-44" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="_K7aeOZNzX8ZAruB3Fqv-43" target="_K7aeOZNzX8ZAruB3Fqv-42" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-35" value="&lt;div&gt;&lt;b&gt;// 计算瓦片的 Screen Space Error&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;function screenSpaceError(primitive, frameState, tile) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.mode === SceneMode.SCENE2D ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.camera.frustum instanceof OrthographicFrustum ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.camera.frustum instanceof OrthographicOffCenterFrustum&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return screenSpaceError2D(primitive, frameState, tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var maxGeometricError = primitive._tileProvider.getLevelMaximumGeometricError(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.level&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var distance = tile._distance;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // canvas 的像素高度&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var height = frameState.context.drawingBufferHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // sseDenominator 的计算公式位于 PerspectiveFrustum.js 第 204 行&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var sseDenominator = frameState.camera.frustum.sseDenominator;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 在 maxGeometricError、canvas 高宽、fov 不变的情况下，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // error 与 distance 成反比，瓦片离相机越远，error 越小&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var error = (maxGeometricError * height) / (distance * sseDenominator);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (frameState.fog.enabled) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; error -=&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; CesiumMath.fog(distance, frameState.fog.density) * frameState.fog.sse;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; error /= frameState.pixelRatio; // pixelRatio 为像素比，一般都是 1&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return error;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;comic=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="1357" y="4368" width="502" height="482" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-39" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-35" vertex="1">
          <mxGeometry x="489" y="154.0038184890417" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-62" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-35" vertex="1">
          <mxGeometry x="398" y="251.9965851628976" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-37" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-36" target="O9qtJ-ZTzyiBhBGTBMVZ-35" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-63" value="&lt;b&gt;// cesium 中默认的 fov 为 pi/3 = 1.0471976...，位于 Camera.js 的构造函数中&lt;/b&gt;&lt;b&gt;&lt;br&gt;frustum._fov = frustum.fov;&lt;br&gt;//&amp;nbsp;&lt;/b&gt;&lt;b&gt;aspectRatio 表示 canvas 的宽高比&lt;br&gt;&lt;/b&gt;&lt;b&gt;// 宽度小于高度时，_fovy 等于 _fov 为固定值，&lt;br&gt;// 宽度大于高度时，_fovy 随宽高比变化而变化&lt;br&gt;&lt;/b&gt;&lt;div&gt;&lt;b&gt;frustum._fovy =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frustum.aspectRatio &amp;lt;= 1 // aspectRatio 表示 canvas 的宽高比&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ? frustum.fov&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);&lt;/b&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="1842" y="4890" width="438" height="156" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-65" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-62" target="O9qtJ-ZTzyiBhBGTBMVZ-63" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-131" value="&lt;div&gt;&lt;b&gt;function addTileToRenderList(primitive, tile) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; primitive._tilesToRender.push(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;shadow=1;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="1228" y="4932" width="281" height="58" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-135" style="rounded=1;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-134" target="zrCMIupTtKye5h8rk7Vh-14" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-147" style="rounded=1;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-146" target="zrCMIupTtKye5h8rk7Vh-14" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-152" value="&lt;div&gt;&lt;b&gt;function visitVisibleChildrenNearToFar(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeast,&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;traversalDetails&lt;/b&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var cameraPosition = frameState.camera.positionCartographic;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileProvider = primitive._tileProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var occluders = primitive._occluders;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var quadDetails = traversalQuadsByLevel[southwest.level];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var southwestDetails = quadDetails.southwest;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var southeastDetails = quadDetails.southeast;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var northwestDetails = quadDetails.northwest;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var northeastDetails = quadDetails.northeast;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (cameraPosition.longitude &amp;lt; southwest.rectangle.east) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (cameraPosition.latitude &amp;lt; southwest.rectangle.north) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Camera in southwest quadrant&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwestDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeastDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwestDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&amp;nbsp;&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeastDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Camera in northwest quadrant&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwestDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwestDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeastDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeastDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else if (cameraPosition.latitude &amp;lt; southwest.rectangle.north) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Camera southeast quadrant&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeastDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwestDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeastDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwestDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Camera in northeast quadrant&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northeastDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;northwestDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeast,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southeastDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visitIfVisible(&lt;/b&gt;&lt;b&gt;primitive,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwest,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tileProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;occluders,&amp;nbsp;&lt;/b&gt;&lt;b&gt;ancestorMeetsSse,&amp;nbsp;&lt;/b&gt;&lt;b&gt;southwestDetails&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; quadDetails.combine(traversalDetails);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;movable=1;" parent="_qH6-IZlokEgzrvQ4-RS-40" vertex="1">
          <mxGeometry x="235" y="7647" width="661" height="604" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-155" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-152" vertex="1">
          <mxGeometry x="9" y="246" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-154" style="edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-153" target="O9qtJ-ZTzyiBhBGTBMVZ-152" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="195" y="6123" />
              <mxPoint x="195" y="7666" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-156" style="rounded=1;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-155" target="_K7aeOZNzX8ZAruB3Fqv-219" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="143" y="7897" />
              <mxPoint x="143" y="3139" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-2" style="rounded=1;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;arcSize=80;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-1" target="zrCMIupTtKye5h8rk7Vh-14">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-71" style="orthogonalLoop=1;jettySize=auto;html=1;rounded=1;jumpStyle=none;edgeStyle=orthogonalEdgeStyle;snapToPoint=0;anchorPointDirection=1;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-70" target="zrCMIupTtKye5h8rk7Vh-14" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-4" style="rounded=1;jumpStyle=none;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;strokeWidth=1;arcSize=80;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-3" target="zrCMIupTtKye5h8rk7Vh-14">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-17" style="jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-14" target="_K7aeOZNzX8ZAruB3Fqv-138">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-14" value="" style="ellipse;html=1;shape=endState;fillColor=#000000;strokeColor=#ff0000;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-40">
          <mxGeometry x="1040" y="4008" width="30" height="30" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-18" value="" style="ellipse;html=1;shape=endState;fillColor=#000000;strokeColor=#ff0000;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-40">
          <mxGeometry x="1192" y="7631" width="30" height="30" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-149" style="orthogonalLoop=1;jettySize=auto;html=1;rounded=1;jumpSize=20;jumpStyle=none;edgeStyle=orthogonalEdgeStyle;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-148" target="zrCMIupTtKye5h8rk7Vh-18" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-30" style="rounded=1;orthogonalLoop=1;jettySize=auto;html=1;jumpStyle=none;jumpSize=20;edgeStyle=orthogonalEdgeStyle;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-29" target="zrCMIupTtKye5h8rk7Vh-18" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-88" style="orthogonalLoop=1;jettySize=auto;html=1;fontSize=25;startSize=40;jumpStyle=none;jumpSize=20;edgeStyle=orthogonalEdgeStyle;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="_K7aeOZNzX8ZAruB3Fqv-87" target="zrCMIupTtKye5h8rk7Vh-18" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-133" style="rounded=1;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;jumpStyle=none;jumpSize=20;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-132" target="O9qtJ-ZTzyiBhBGTBMVZ-131" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-145" style="rounded=1;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;jumpStyle=none;jumpSize=20;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-144" target="O9qtJ-ZTzyiBhBGTBMVZ-131" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-158" style="rounded=1;orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;jumpStyle=none;jumpSize=20;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="O9qtJ-ZTzyiBhBGTBMVZ-157" target="O9qtJ-ZTzyiBhBGTBMVZ-131" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-23" style="edgeStyle=orthogonalEdgeStyle;rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeWidth=1;arcSize=80;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-21" target="O9qtJ-ZTzyiBhBGTBMVZ-131">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-26" style="edgeStyle=orthogonalEdgeStyle;rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;arcSize=80;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-25" target="zrCMIupTtKye5h8rk7Vh-14">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="1016" y="3987" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-36" style="edgeStyle=orthogonalEdgeStyle;rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;arcSize=80;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-35" target="zrCMIupTtKye5h8rk7Vh-18">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-38" value="&lt;div&gt;&lt;b&gt;function containsNeededPosition(primitive, tile) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var rectangle = tile.rectangle;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; (defined(primitive._cameraPositionCartographic) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Rectangle.contains(rectangle, primitive._cameraPositionCartographic)) ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; (defined(primitive._cameraReferenceFrameOriginCartographic) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Rectangle.contains(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; primitive._cameraReferenceFrameOriginCartographic&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ))&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-40">
          <mxGeometry x="1261" y="3451" width="458" height="184" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-39" style="rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-37" target="zrCMIupTtKye5h8rk7Vh-38">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-42" style="edgeStyle=orthogonalEdgeStyle;rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;arcSize=80;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-41" target="zrCMIupTtKye5h8rk7Vh-14">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-140" style="rounded=1;sketch=0;jumpStyle=none;orthogonalLoop=1;jettySize=auto;html=1;fontSize=75;edgeStyle=orthogonalEdgeStyle;arcSize=80;" parent="_qH6-IZlokEgzrvQ4-RS-40" source="_K7aeOZNzX8ZAruB3Fqv-139" target="zrCMIupTtKye5h8rk7Vh-14" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-45" style="edgeStyle=orthogonalEdgeStyle;rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;arcSize=80;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-44" target="zrCMIupTtKye5h8rk7Vh-14">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-46" value="&lt;div&gt;&lt;b&gt;function createRenderCommandsForSelectedTiles(primitive, frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileProvider = primitive._tileProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tilesToRender = primitive._tilesToRender;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var i = 0, len = tilesToRender.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var tile = tilesToRender[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileProvider.showTileThisFrame(tile, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-40">
          <mxGeometry x="866" y="1263" width="445" height="142" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-50" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-46">
          <mxGeometry x="304" y="98" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-48" style="rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-40" source="zrCMIupTtKye5h8rk7Vh-47" target="zrCMIupTtKye5h8rk7Vh-46">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="cho-rxJkQNWqNleOSbak-8" style="orthogonalLoop=1;jettySize=auto;html=1;dashed=1;strokeWidth=1;elbow=vertical;curved=1;dashPattern=1 4;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-44" target="_qH6-IZlokEgzrvQ4-RS-27" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="513.0000000000001" y="465" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="cho-rxJkQNWqNleOSbak-9" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;dashed=1;strokeWidth=1;curved=1;dashPattern=1 4;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-45" target="_qH6-IZlokEgzrvQ4-RS-29" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="798" y="465" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-76" value="GlobeSurfaceTileProvider.js" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="7591" y="-510" width="1383" height="13002" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-77" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* 持续加载指定瓦片。该函数会被持续调用&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* 直到 {@link QuadtreeTile#state} 不再是 {@link QuadtreeTileLoadState#LOADING}。该函数在 This function should&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* {@link GlobeSurfaceTileProvider#ready} 返回 ture 之前不应当被调用。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* @param {FrameState} frameState The frame state.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* @param {QuadtreeTile} tile The tile to load.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;* @exception {DeveloperError} &amp;lt;code&amp;gt;loadTile&amp;lt;/code&amp;gt; must not be called before the tile provider is ready.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.loadTile = function (frameState, tile) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 我们只有在确定地形瓦片是真实可见的情况下才会加影像。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // So if our bounding volume isn&#39;t accurate because it came from another tile, load terrain only&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // initially. 如果我们加载了一些地形，突然包含了更精确的包围体，并且&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 瓦片 仍然 可见，给瓦片一个机会马上加载影像而不是等到&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 下一帧。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainOnly = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainStateBefore;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(surfaceTile)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainOnly =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.boundingVolumeSourceTile !== tile ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile._lastSelectionResult === TileSelectionResult.CULLED_BUT_NEEDED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainStateBefore = surfaceTile.terrainState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; GlobeSurfaceTile.processStateMachine(&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;this.terrainProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;this._imageryLayers,&amp;nbsp;&lt;/b&gt;&lt;b&gt;this._vertexArraysToDestroy,&amp;nbsp;&lt;/b&gt;&lt;b&gt;terrainOnly&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (terrainOnly &amp;amp;&amp;amp; terrainStateBefore !== tile.data.terrainState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 地形状态发生了变化。如果&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // a) 瓦片可见，并且&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // b) 包围体是准确的（计算可见性引发的更新）&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Then we&#39;ll load imagery, too.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;b&gt;this.computeTileVisibility(tile, frameState, this.quadtree.occluders) !==&amp;nbsp;&lt;/b&gt;&lt;b&gt;Visibility.NONE &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.boundingVolumeSourceTile === tile&lt;/b&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainOnly = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; GlobeSurfaceTile.processStateMachine(&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;this.terrainProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;this._imageryLayers,&amp;nbsp;&lt;/b&gt;&lt;b&gt;this._vertexArraysToDestroy,&amp;nbsp;&lt;/b&gt;&lt;b&gt;terrainOnly&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="44.5" y="9700" width="1148.5" height="610" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-78" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;startSize=40;fontSize=25;" parent="_qH6-IZlokEgzrvQ4-RS-77" vertex="1">
          <mxGeometry x="821.5" y="392" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-79" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;startSize=40;fontSize=25;" parent="_qH6-IZlokEgzrvQ4-RS-77" vertex="1">
          <mxGeometry x="833.5" y="547" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-178" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-77">
          <mxGeometry x="551.5" y="504" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-32" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Make updates to the tile provider that are not involved in rendering. Called before the render update cycle.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.update = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // update collection: imagery indices, base layers, raise layer show/hide event&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._imageryLayers._update();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="21" y="208" width="638" height="114" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-39" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-32" vertex="1">
          <mxGeometry x="194" y="84" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-57" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Called at the beginning of each render frame, before {@link QuadtreeTileProvider#showTileThisFrame}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The frame state.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.initialize = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // update each layer for texture reprojection.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._imageryLayers.queueReprojectionCommands(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (this._layerOrderChanged) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._layerOrderChanged = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Sort the TileImagery instances in each tile by the layer index.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._quadtree.forEachLoadedTile(function (tile) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile.data.imagery.sort(sortTileImageryByLayerIndex);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Add credits for terrain and imagery providers.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; updateCredits(this, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var vertexArraysToDestroy = this._vertexArraysToDestroy;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var length = vertexArraysToDestroy.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var j = 0; j &amp;lt; length; ++j) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; GlobeSurfaceTile._freeVertexArray(vertexArraysToDestroy[j]);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; vertexArraysToDestroy.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;resizeWidth=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="21" y="404" width="619" height="394" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-61" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-57" vertex="1">
          <mxGeometry x="386" y="98" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-39" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Called at the beginning of the update cycle for each render frame,&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* before {@link QuadtreeTileProvider#showTileThisFrame}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* or any other functions.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The frame state.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.beginUpdate = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 清空 _tilesToRenderByTextureCount，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // _tilesToRenderByTextureCount 是一个二维数组，储存了瓦片&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var i = 0, len = tilesToRenderByTextureCount.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var tiles = tilesToRenderByTextureCount[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(tiles)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tiles.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 更新 clipping planes&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var clippingPlanes = this._clippingPlanes;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(clippingPlanes) &amp;amp;&amp;amp; clippingPlanes.enabled) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; clippingPlanes.update(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._usedDrawCommands = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._hasLoadedTilesThisFrame = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._hasFillTilesThisFrame = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="21" y="836" width="446" height="394" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-2" value="&lt;div&gt;&lt;b&gt;var tileDirectionScratch = new Cartesian3();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Determines the priority for loading this tile. Lower priority values load sooner.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {QuadtreeTile} tile The tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The frame state.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} The load priority value.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.computeTileLoadPriority = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 没有 tile.data，则加载优先级最高&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (surfaceTile === undefined) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 没有 orientedBoundingBox，则加载优先级最高&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var obb = surfaceTile.orientedBoundingBox;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (obb === undefined) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 计算从 orientedBoundingBox 中心指向摄像机的向量&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var cameraPosition = frameState.camera.positionWC;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var cameraDirection = frameState.camera.directionWC;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileDirection = Cartesian3.subtract(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; obb.center,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; cameraPosition,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileDirectionScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 计算向量的长度&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var magnitude = Cartesian3.magnitude(tileDirection);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 如果向量的长度小于 0.00001，即摄像机距离瓦片特别近，则优先级最高&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (magnitude &amp;lt; CesiumMath.EPSILON5) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 向量单位化&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; Cartesian3.divideByScalar(tileDirection, magnitude, tileDirection);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 点乘表示瓦片法线向量在摄像机方向上的投影，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 方向夹角越小，投影越大，(1.0 - 投影越小)，优先级越高；&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 瓦片至摄像机的距离越大，优先级越低；&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 返回结果是两者的乘积&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; (1.0 - Cartesian3.dot(tileDirection, cameraDirection)) * tile._distance&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="87" y="3384" width="477" height="674" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-20" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* 计算瓦片的可见性，结果包括可见、部分可见和不可见。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* 可被渲染且可见性为可见或部分可见的瓦片会被显示，通过调用&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* {@link GlobeSurfaceTileProvider#showTileThisFrame}.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {QuadtreeTile} tile The tile instance.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The state information about the current frame.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {QuadtreeOccluders} occluders The objects that may occlude this tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Visibility} Visibility.NONE if the tile is not visible,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Visibility.PARTIAL if the tile is partially visible, or&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;Visibility.FULL if the tile is fully visible.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.computeTileVisibility = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; occluders&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 计算到瓦片的距离，并将其赋给瓦片的 _distance&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var distance = this.computeDistanceToTile(tile, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile._distance = distance;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 地下物体是否可见&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var undergroundVisible = isUndergroundVisible(this, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 雾中的物体不可见&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (frameState.fog.enabled &amp;amp;&amp;amp; !undergroundVisible) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (CesiumMath.fog(distance, frameState.fog.density) &amp;gt;= 1.0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Tile is completely in fog so return that it is not visible.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return Visibility.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data; // 储存了瓦片的网格等数据&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileBoundingRegion = surfaceTile.tileBoundingRegion;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (surfaceTile.boundingVolumeSourceTile === undefined) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 无法确定瓦片的位置，则返回部分可见&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return Visibility.PARTIAL;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var cullingVolume = frameState.cullingVolume;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 将包围盒设为方向包围盒&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var boundingVolume = surfaceTile.orientedBoundingBox;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 如果没有方向包围盒，则使用网格的包围球&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(boundingVolume) &amp;amp;&amp;amp; defined(surfaceTile.renderedMesh)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; boundingVolume = surfaceTile.renderedMesh.boundingSphere3D;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Check if the tile is outside the limit area in cartographic space&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 检查瓦片是否位于地图空间外&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; surfaceTile.clippedByBoundaries = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var clippedCartographicLimitRectangle = clipRectangleAntimeridian(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this.cartographicLimitRectangle&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var areaLimitIntersection = Rectangle.simpleIntersection(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; clippedCartographicLimitRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; rectangleIntersectionScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(areaLimitIntersection)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return Visibility.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!Rectangle.equals(areaLimitIntersection, tile.rectangle)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.clippedByBoundaries = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 非 3D 模式&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (frameState.mode !== SceneMode.SCENE3D) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; boundingVolume = boundingSphereScratch;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; BoundingSphere.fromRectangleWithHeights2D(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile.rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; frameState.mapProjection,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tileBoundingRegion.minimumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tileBoundingRegion.maximumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Cartesian3.fromElements(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume.center.z,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume.center.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume.center.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume.center&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; frameState.mode === SceneMode.MORPHING &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; defined(surfaceTile.renderedMesh)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume = BoundingSphere.union(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.renderedMesh.boundingSphere3D,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 非 3D 模式结束标记&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 如果没有定义包围盒（方向包围盒或包围球），&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 则返回部分可见&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(boundingVolume)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return Visibility.PARTIAL;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 计算是否被剪切面（如果开启）剪切&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var clippingPlanes = this._clippingPlanes;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(clippingPlanes) &amp;amp;&amp;amp; clippingPlanes.enabled) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var planeIntersection = clippingPlanes.computeIntersectionWithBoundingVolume(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingVolume&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.isClipped = planeIntersection !== Intersect.INSIDE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (planeIntersection === Intersect.OUTSIDE) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return Visibility.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 计算是否被 cullingVolume 剪切&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var visibility;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var intersection = cullingVolume.computeVisibility(boundingVolume);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (intersection === Intersect.OUTSIDE) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visibility = Visibility.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else if (intersection === Intersect.INTERSECTING) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visibility = Visibility.PARTIAL;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else if (intersection === Intersect.INSIDE) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; visibility = Visibility.FULL;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (visibility === Visibility.NONE) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return visibility;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 处理正射投影&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var ortho3D =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.mode === SceneMode.SCENE3D &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.camera.frustum instanceof OrthographicFrustum;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.mode === SceneMode.SCENE3D &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !ortho3D &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(occluders) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !undergroundVisible&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!defined(occludeePointInScaledSpace)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return visibility;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; occluders.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; occludeePointInScaledSpace,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tileBoundingRegion.minimumHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; )&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return visibility;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return Visibility.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 处理正射投影结束标记&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return visibility;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="815" y="3360" width="504" height="2284" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-40" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Gets the maximum geometric error allowed in a tile at a given level, in meters.&amp;nbsp; This function should not be&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* called before {@link GlobeSurfaceTileProvider#ready} returns true.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The tile level for which to get the maximum geometric error.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} The maximum geometric error in meters.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; level&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return this._terrainProvider.getLevelMaximumGeometricError(level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="51" y="4410" width="641" height="184" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-45" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-40" vertex="1">
          <mxGeometry x="407.5" y="155" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-67" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Determines if the given not-fully-loaded tile can be rendered without losing detail that&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* was present last frame as a result of rendering descendant tiles. This method will only be&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* called if this tile&#39;s descendants were rendered last frame. If the tile is fully loaded,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* it is assumed that this method will return true and it will not be called.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {QuadtreeTile} tile The tile to check.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {boolean} True if the tile can be rendered without losing detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var readyImagery = readyImageryScratch;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; readyImagery.length = this._imageryLayers.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainReady = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var initialImageryState = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var imagery;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(surfaceTile)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // We can render even with non-ready terrain as long as all our rendered descendants&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // are missing terrain geometry too. i.e. if we rendered fills for more detailed tiles&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // last frame, it&#39;s ok to render a fill for this tile this frame.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainReady = surfaceTile.terrainState === TerrainState.READY;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Initially assume all imagery layers are ready, unless imagery hasn&#39;t been initialized at all.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; initialImageryState = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imagery = surfaceTile.imagery;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var i;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var len;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (i = 0, len = readyImagery.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; readyImagery[i] = initialImageryState;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(imagery)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (i = 0, len = imagery.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var tileImagery = imagery[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var loadingImagery = tileImagery.loadingImagery;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var isReady =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !defined(loadingImagery) ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; loadingImagery.state === ImageryState.FAILED ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; loadingImagery.state === ImageryState.INVALID;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var layerIndex = (tileImagery.loadingImagery || tileImagery.readyImagery)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; .imageryLayer._layerIndex;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // For a layer to be ready, all tiles belonging to that layer must be ready.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; readyImagery[layerIndex] = isReady &amp;amp;&amp;amp; readyImagery[layerIndex];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var lastFrame = this.quadtree._lastSelectionFrameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Traverse the descendants looking for one with terrain or imagery that is not loaded on this tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var stack = canRenderTraversalStack;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; stack.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; stack.push(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.southwestChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.southeastChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.northwestChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.northeastChild&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; while (stack.length &amp;gt; 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var descendant = stack.pop();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var lastFrameSelectionResult =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; descendant._lastSelectionResultFrame === lastFrame&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ? descendant._lastSelectionResult&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : TileSelectionResult.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (lastFrameSelectionResult === TileSelectionResult.RENDERED) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var descendantSurface = descendant.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (!defined(descendantSurface)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Descendant has no data, so it can&#39;t block rendering.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; continue;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !terrainReady &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendant.data.terrainState === TerrainState.READY&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Rendered descendant has real terrain, but we don&#39;t. Rendering is blocked.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var descendantImagery = descendant.data.imagery;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; for (i = 0, len = descendantImagery.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var descendantTileImagery = descendantImagery[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var descendantLoadingImagery = descendantTileImagery.loadingImagery;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var descendantIsReady =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !defined(descendantLoadingImagery) ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendantLoadingImagery.state === ImageryState.FAILED ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendantLoadingImagery.state === ImageryState.INVALID;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; var descendantLayerIndex = (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendantTileImagery.loadingImagery ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendantTileImagery.readyImagery&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ).imageryLayer._layerIndex;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // If this imagery tile of a descendant is ready but the layer isn&#39;t ready in this tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // then rendering is blocked.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (descendantIsReady &amp;amp;&amp;amp; !readyImagery[descendantLayerIndex]) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else if (lastFrameSelectionResult === TileSelectionResult.REFINED) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; stack.push(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendant.southwestChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendant.southeastChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendant.northwestChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; descendant.northeastChild&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="51" y="4931" width="578" height="1724" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-137" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Determines if the given tile can be refined&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {QuadtreeTile} tile The tile to check.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {boolean} True if the tile can be refined, false if it cannot.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.canRefine = function (tile) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Only allow refinement it we know whether or not the children of this tile exist.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // For a tileset with `availability`, we&#39;ll always be able to refine.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // We can ask for availability of _any_ child tile because we only need to confirm&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // that we get a yes or no answer, it doesn&#39;t matter what the answer is.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(tile.data.terrainData)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var childAvailable = this.terrainProvider.getTileDataAvailable(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.x * 2,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.y * 2,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.level + 1&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return childAvailable !== undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-76" vertex="1">
          <mxGeometry x="50" y="4612" width="484" height="296" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-140" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;" parent="O9qtJ-ZTzyiBhBGTBMVZ-137" vertex="1">
          <mxGeometry x="368" y="197" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-49" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Shows a specified tile in this frame.&amp;nbsp; The provider can cause the tile to be shown by adding&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* render commands to the commandList, or use any other method as appropriate.&amp;nbsp; The tile is not&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* expected to be visible next frame as well, unless this method is called next frame, too.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {QuadtreeTile} tile The tile instance.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The state information of the current rendering frame.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.showTileThisFrame = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var readyTextureCount = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileImageryCollection = tile.data.imagery;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var i = 0, len = tileImageryCollection.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var tileImagery = tileImageryCollection[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; defined(tileImagery.readyImagery) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tileImagery.readyImagery.imageryLayer.alpha !== 0.0&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ++readyTextureCount;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileSet = this._tilesToRenderByTextureCount[readyTextureCount];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(tileSet)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileSet = [];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._tilesToRenderByTextureCount[readyTextureCount] = tileSet;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tileSet.push(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(surfaceTile.vertexArray)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._hasFillTilesThisFrame = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._hasLoadedTilesThisFrame = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var debug = this._debug;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ++debug.tilesRendered;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; debug.texturesRendered += readyTextureCount;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-76">
          <mxGeometry x="21" y="1271" width="575" height="618" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-52" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Called at the end of the update cycle for each render frame, after {@link QuadtreeTileProvider#showTileThisFrame}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* and any other functions.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The frame state.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GlobeSurfaceTileProvider.prototype.endUpdate = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(this._renderState)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._renderState = RenderState.fromCache({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Write color and depth&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; cull: {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; enabled: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; depthTest: {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; enabled: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; func: DepthFunction.LESS,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._blendRenderState = RenderState.fromCache({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Write color and depth&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; cull: {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; enabled: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; depthTest: {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; enabled: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; func: DepthFunction.LESS_OR_EQUAL,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; blending: BlendingState.ALPHA_BLEND,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var rs = clone(this._renderState, true);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; rs.cull.enabled = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._disableCullingRenderState = RenderState.fromCache(rs);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; rs = clone(this._blendRenderState, true);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; rs.cull.enabled = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._disableCullingBlendRenderState = RenderState.fromCache(rs);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // If this frame has a mix of loaded and fill tiles, we need to propagate&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // loaded heights to the fill tiles.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (this._hasFillTilesThisFrame &amp;amp;&amp;amp; this._hasLoadedTilesThisFrame) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; TerrainFillMesh.updateFillTiles(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this._quadtree._tilesToRender,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; frameState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this._vertexArraysToDestroy&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Add the tile render commands to the command list, sorted by texture count.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tilesToRenderByTextureCount = this._tilesToRenderByTextureCount;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var textureCountIndex = 0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; textureCountLength = tilesToRenderByTextureCount.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; textureCountIndex &amp;lt; textureCountLength;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ++textureCountIndex&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var tilesToRender = tilesToRenderByTextureCount[textureCountIndex];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!defined(tilesToRender)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; continue;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var tileIndex = 0, tileLength = tilesToRender.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tileIndex &amp;lt; tileLength;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ++tileIndex&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var tile = tilesToRender[tileIndex];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var tileBoundingRegion = tile.data.tileBoundingRegion;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; addDrawCommandsForTile(this, tile, frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; frameState.minimumTerrainHeight = Math.min(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; frameState.minimumTerrainHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tileBoundingRegion.minimumHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-76">
          <mxGeometry x="26" y="1914" width="689" height="1122" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-177" style="edgeStyle=none;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-76" source="zrCMIupTtKye5h8rk7Vh-178" target="O9qtJ-ZTzyiBhBGTBMVZ-20">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-80" value="GlobeSurfaceTile.js" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="9083" y="9112" width="2212" height="3894" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-81" value="&lt;div&gt;&lt;b&gt;GlobeSurfaceTile.processStateMachine = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; terrainProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; imageryLayerCollection,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; vertexArraysToDestroy,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; terrainOnly&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; GlobeSurfaceTile.initialize(tile, terrainProvider, imageryLayerCollection);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (tile.state === QuadtreeTileLoadState.LOADING) { // 待分析是什么时候被赋值的？？？&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; processTerrainStateMachine(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; frameState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryLayerCollection,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; vertexArraysToDestroy&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // From here down we&#39;re loading imagery, not terrain. We don&#39;t want to load imagery until&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // we&#39;re certain that the terrain tiles are actually visible, though. We&#39;ll load terrainOnly&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // in these scenarios:&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;nbsp; &amp;nbsp;* our bounding volume isn&#39;t accurate so we&#39;re not certain this tile is&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // really visible (see GlobeSurfaceTileProvider#loadTile).&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;nbsp; &amp;nbsp;* we want to upsample from this tile but don&#39;t plan to render it (see processTerrainStateMachine).&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (terrainOnly) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var wasAlreadyRenderable = tile.renderable;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // The terrain is renderable as soon as we have a valid vertex array.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile.renderable = defined(surfaceTile.vertexArray);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // But it&#39;s not done loading until it&#39;s in the READY state.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var isTerrainDoneLoading = surfaceTile.terrainState === TerrainState.READY;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // If this tile&#39;s terrain and imagery are just upsampled from its parent, mark the tile as&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // upsampled only.&amp;nbsp; We won&#39;t refine a tile if its four children are upsampled only.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile.upsampledFromParent =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(surfaceTile.terrainData) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.terrainData.wasCreatedByUpsampling();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var isImageryDoneLoading = surfaceTile.processImagery(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (isTerrainDoneLoading &amp;amp;&amp;amp; isImageryDoneLoading) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var callbacks = tile._loadedCallbacks;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var newCallbacks = {};&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (var layerId in callbacks) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (callbacks.hasOwnProperty(layerId)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (!callbacks[layerId](tile)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; newCallbacks[layerId] = callbacks[layerId];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile._loadedCallbacks = newCallbacks;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.state = QuadtreeTileLoadState.DONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Once a tile is renderable, it stays renderable, because doing otherwise would&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // cause detail (or maybe even the entire globe) to vanish when adding a new&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // imagery layer. `GlobeSurfaceTileProvider._onLayerAdded` sets renderable to&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // false for all affected tiles that are not currently being rendered.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (wasAlreadyRenderable) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.renderable = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" parent="_qH6-IZlokEgzrvQ4-RS-80" vertex="1">
          <mxGeometry x="168" y="202" width="599" height="1066" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-84" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;startSize=40;fontSize=25;" parent="_qH6-IZlokEgzrvQ4-RS-81" vertex="1">
          <mxGeometry x="431" y="127" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-180" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-81">
          <mxGeometry x="8" y="197" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-82" value="&lt;div&gt;&lt;b&gt;GlobeSurfaceTile.initialize = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; terrainProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; imageryLayerCollection&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(surfaceTile)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile = tile.data = new GlobeSurfaceTile();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (tile.state === QuadtreeTileLoadState.START) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; prepareNewTile(tile, terrainProvider, imageryLayerCollection);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.state = QuadtreeTileLoadState.LOADING;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-80" vertex="1">
          <mxGeometry x="789" y="205" width="389" height="226" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-90" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;startSize=40;fontSize=25;" parent="_qH6-IZlokEgzrvQ4-RS-82" vertex="1">
          <mxGeometry x="374" y="169" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-83" value="&lt;div&gt;&lt;b&gt;function prepareNewTile(tile, terrainProvider, imageryLayerCollection) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var available = terrainProvider.getTileDataAvailable(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.level&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(available) &amp;amp;&amp;amp; defined(tile.parent)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Provider doesn&#39;t know if this tile is available. Does the parent tile know?&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var parent = tile.parent;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var parentSurfaceTile = parent.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(parentSurfaceTile) &amp;amp;&amp;amp; defined(parentSurfaceTile.terrainData)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; available = parentSurfaceTile.terrainData.isChildAvailable(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parent.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; parent.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tile.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tile.y&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (available === false) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // This tile is not available, so mark it failed so we start upsampling right away.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.data.terrainState = TerrainState.FAILED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Map imagery tiles to this terrain tile&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var i = 0, len = imageryLayerCollection.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var layer = imageryLayerCollection.get(i);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (layer.show) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layer._createTileImagerySkeletons(tile, terrainProvider);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-80" vertex="1">
          <mxGeometry x="1249" y="198" width="480" height="492" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-100" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;startSize=40;fontSize=25;" parent="_qH6-IZlokEgzrvQ4-RS-83" vertex="1">
          <mxGeometry x="312" y="28" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-106" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;startSize=40;fontSize=25;" parent="_qH6-IZlokEgzrvQ4-RS-83" vertex="1">
          <mxGeometry x="346" y="434" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-85" style="orthogonalLoop=1;jettySize=auto;html=1;startSize=40;strokeColor=#000000;fontSize=25;" parent="_qH6-IZlokEgzrvQ4-RS-80" source="_qH6-IZlokEgzrvQ4-RS-84" target="_qH6-IZlokEgzrvQ4-RS-82" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-91" style="orthogonalLoop=1;jettySize=auto;html=1;startSize=40;strokeColor=#000000;fontSize=25;" parent="_qH6-IZlokEgzrvQ4-RS-80" source="_qH6-IZlokEgzrvQ4-RS-90" target="_qH6-IZlokEgzrvQ4-RS-83" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-179" value="&lt;div&gt;&lt;b&gt;function processTerrainStateMachine(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; terrainProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; imageryLayerCollection,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; vertexArraysToDestroy&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 如果当前瓦片的状态是 FAILED，则需要从父级上取样。如果父瓦片没有&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 准备完毕，则继续向上&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var parent = tile.parent;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.terrainState === TerrainState.FAILED &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; parent !== undefined&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var parentReady =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; parent.data !== undefined &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; parent.data.terrainData !== undefined &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; parent.data.terrainData.canUpsample !== false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!parentReady) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; GlobeSurfaceTile.processStateMachine(&lt;/b&gt;&lt;b&gt;parent,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;terrainProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;imageryLayerCollection,&amp;nbsp;&lt;/b&gt;&lt;b&gt;true&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (surfaceTile.terrainState === TerrainState.FAILED) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; upsample(&lt;/b&gt;&lt;b&gt;surfaceTile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;terrainProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.x,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.y,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.level&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (surfaceTile.terrainState === TerrainState.UNLOADED) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; requestTileGeometry(&lt;/b&gt;&lt;b&gt;surfaceTile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;terrainProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.x,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.y,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.level&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (surfaceTile.terrainState === TerrainState.RECEIVED) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; transform(&lt;/b&gt;&lt;b&gt;surfaceTile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState,&amp;nbsp;&lt;/b&gt;&lt;b&gt;terrainProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.x,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.y,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.level&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (surfaceTile.terrainState === TerrainState.TRANSFORMED) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; createResources(&lt;/b&gt;&lt;b&gt;surfaceTile,&amp;nbsp;&lt;/b&gt;&lt;b&gt;frameState.context,&amp;nbsp;&lt;/b&gt;&lt;b&gt;terrainProvider,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.x,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.y,&amp;nbsp;&lt;/b&gt;&lt;b&gt;tile.level,&amp;nbsp;&lt;/b&gt;&lt;b&gt;vertexArraysToDestroy&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;b&gt;surfaceTile.terrainState &amp;gt;= TerrainState.RECEIVED &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.waterMaskTexture === undefined &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainProvider.hasWaterMask&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var terrainData = surfaceTile.terrainData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (terrainData.waterMask !== undefined) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; createWaterMaskTextureIfNeeded(frameState.context, surfaceTile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var sourceTile = surfaceTile._findAncestorTileWithTerrainData(tile);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (defined(sourceTile) &amp;amp;&amp;amp; defined(sourceTile.data.waterMaskTexture)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.waterMaskTexture = sourceTile.data.waterMaskTexture;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ++surfaceTile.waterMaskTexture.referenceCount;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile._computeWaterMaskTranslationAndScale(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sourceTile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.waterMaskTranslationAndScale&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-80">
          <mxGeometry x="168" y="1295" width="688" height="885" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-182" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-179">
          <mxGeometry x="13" y="308" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-185" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-179">
          <mxGeometry x="461" y="378" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-199" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-179">
          <mxGeometry x="433" y="435" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-202" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-179">
          <mxGeometry x="666" y="546" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-209" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-179">
          <mxGeometry x="437" y="491" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-181" style="rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;edgeStyle=orthogonalEdgeStyle;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-80" source="zrCMIupTtKye5h8rk7Vh-180" target="zrCMIupTtKye5h8rk7Vh-179">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="120" y="403" />
              <mxPoint x="120" y="1314" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-183" style="edgeStyle=orthogonalEdgeStyle;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-80" source="zrCMIupTtKye5h8rk7Vh-182" target="_qH6-IZlokEgzrvQ4-RS-81">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="124" y="264" as="targetPoint" />
            <Array as="points">
              <mxPoint x="77" y="1606" />
              <mxPoint x="77" y="219" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-184" value="&lt;div&gt;&lt;b&gt;function upsample(surfaceTile, tile, frameState, terrainProvider, x, y, level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var parent = tile.parent;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!parent) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Trying to upsample from a root tile. No can do. This tile is a failure.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.state = QuadtreeTileLoadState.FAILED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var sourceData = parent.data.terrainData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var sourceX = parent.x;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var sourceY = parent.y;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var sourceLevel = parent.level;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(sourceData)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Parent is not available, so we can&#39;t upsample this tile yet.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainDataPromise = sourceData.upsample(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainProvider.tilingScheme,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; sourceX,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; sourceY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; sourceLevel,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; level&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(terrainDataPromise)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // The upsample request has been deferred - try again later.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; surfaceTile.terrainState = TerrainState.RECEIVING;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; when(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainDataPromise,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; function (terrainData) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainData = terrainData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.RECEIVED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; },&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; function () {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.FAILED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-80">
          <mxGeometry x="990" y="978" width="452" height="646" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-194" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-184">
          <mxGeometry x="293" y="267" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-186" style="rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-80" source="zrCMIupTtKye5h8rk7Vh-185" target="zrCMIupTtKye5h8rk7Vh-184">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-197" value="&lt;div&gt;&lt;b&gt;function requestTileGeometry(surfaceTile, terrainProvider, x, y, level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 加载成功时运行的函数&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; function success(terrainData) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.terrainData = terrainData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.RECEIVED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.request = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 加载失败时运行的函数&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; function failure() {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (surfaceTile.request.state === RequestState.CANCELLED) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Cancelled due to low priority - try again later.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainData = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.UNLOADED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.request = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Initially assume failure.&amp;nbsp; handleError may retry, in which case the state will&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // change to RECEIVING or UNLOADED.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.FAILED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.request = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var message =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;Failed to obtain terrain tile X: &quot; +&amp;nbsp;&lt;/b&gt;&lt;b&gt;x +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot; Y: &quot; +&amp;nbsp;&lt;/b&gt;&lt;b&gt;y +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot; Level: &quot; +&amp;nbsp;&lt;/b&gt;&lt;b&gt;level +&amp;nbsp;&lt;/b&gt;&lt;b&gt;&quot;.&quot;;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainProvider._requestError = TileProviderError.handleError(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainProvider._requestError,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainProvider.errorEvent,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; message,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; doRequest&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; function doRequest() {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Request the terrain from the terrain provider.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var request = new Request({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; throttle: false,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; throttleByServer: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; type: RequestType.TERRAIN,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.request = request;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var requestPromise = terrainProvider.requestTileGeometry(&lt;/b&gt;&lt;b&gt;x,&amp;nbsp;&lt;/b&gt;&lt;b&gt;y,&amp;nbsp;&lt;/b&gt;&lt;b&gt;level,&amp;nbsp;&lt;/b&gt;&lt;b&gt;request&lt;/b&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // If the request method returns undefined (instead of a promise), the request&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // has been deferred.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(requestPromise)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.RECEIVING;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; when(requestPromise, success, failure);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Deferred - try again later.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.UNLOADED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.request = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; doRequest();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-80">
          <mxGeometry x="990" y="1658" width="484" height="898" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-200" style="rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-80" source="zrCMIupTtKye5h8rk7Vh-199" target="zrCMIupTtKye5h8rk7Vh-197">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-201" value="&lt;div&gt;&lt;b&gt;function createResources(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; surfaceTile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; context,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; terrainProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; vertexArraysToDestroy&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; surfaceTile.vertexArray = GlobeSurfaceTile._createVertexArrayForMesh(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; context,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.mesh&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; surfaceTile.terrainState = TerrainState.READY;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; surfaceTile.fill =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.fill &amp;amp;&amp;amp; surfaceTile.fill.destroy(vertexArraysToDestroy);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-80">
          <mxGeometry x="990" y="3224" width="441" height="254" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-206" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-201">
          <mxGeometry x="429" y="140" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-205" value="&lt;div&gt;&lt;b&gt;GlobeSurfaceTile._createVertexArrayForMesh = function (context, mesh) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var typedArray = mesh.vertices;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var buffer = Buffer.createVertexBuffer({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; context: context,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; typedArray: typedArray,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; usage: BufferUsage.STATIC_DRAW,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var attributes = mesh.encoding.getAttributes(buffer);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var indexBuffers = mesh.indices.indexBuffers || {};&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var indexBuffer = indexBuffers[context.id];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(indexBuffer) || indexBuffer.isDestroyed()) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var indices = mesh.indices;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; indexBuffer = Buffer.createIndexBuffer({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; context: context,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; typedArray: indices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; usage: BufferUsage.STATIC_DRAW,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indexDatatype: IndexDatatype.fromSizeInBytes(indices.BYTES_PER_ELEMENT),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; indexBuffer.vertexArrayDestroyable = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; indexBuffer.referenceCount = 1;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; indexBuffers[context.id] = indexBuffer;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; mesh.indices.indexBuffers = indexBuffers;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ++indexBuffer.referenceCount;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return new VertexArray({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; context: context,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; attributes: attributes,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; indexBuffer: indexBuffer,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-80">
          <mxGeometry x="1543" y="3118" width="502" height="478" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-207" style="edgeStyle=none;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-80" source="zrCMIupTtKye5h8rk7Vh-206" target="zrCMIupTtKye5h8rk7Vh-205">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-208" value="&lt;div&gt;&lt;b&gt;function transform(surfaceTile, frameState, terrainProvider, x, y, level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tilingScheme = terrainProvider.tilingScheme;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainData = surfaceTile.terrainData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var meshPromise = terrainData.createMesh(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tilingScheme,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.terrainExaggeration&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(meshPromise)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Postponed.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; surfaceTile.terrainState = TerrainState.TRANSFORMING;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; when(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; meshPromise,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; function (mesh) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.mesh = mesh;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.orientedBoundingBox = OrientedBoundingBox.clone(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mesh.orientedBoundingBox,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.orientedBoundingBox&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.occludeePointInScaledSpace = Cartesian3.clone(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; mesh.occludeePointInScaledSpace,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.occludeePointInScaledSpace&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.TRANSFORMED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; },&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; function () {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.terrainState = TerrainState.FAILED;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;recursiveResize=0;" vertex="1" parent="_qH6-IZlokEgzrvQ4-RS-80">
          <mxGeometry x="990" y="2584" width="428" height="548" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-212" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-208">
          <mxGeometry x="271" y="71" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-203" style="edgeStyle=none;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-80" source="zrCMIupTtKye5h8rk7Vh-202" target="zrCMIupTtKye5h8rk7Vh-201">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-210" style="edgeStyle=none;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="_qH6-IZlokEgzrvQ4-RS-80" source="zrCMIupTtKye5h8rk7Vh-209" target="zrCMIupTtKye5h8rk7Vh-208">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-88" style="orthogonalLoop=1;jettySize=auto;html=1;startSize=40;strokeColor=#000000;fontSize=25;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-78" target="_qH6-IZlokEgzrvQ4-RS-81" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-89" style="orthogonalLoop=1;jettySize=auto;html=1;startSize=40;strokeColor=#000000;fontSize=25;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-79" target="_qH6-IZlokEgzrvQ4-RS-81" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="9155" y="2517.3333333333335" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-98" value="ImageryLayer.js" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="17003" y="117" width="813" height="7184" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-99" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Create skeletons for the imagery tiles that partially or completely overlap a given terrain&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Tile} tile The terrain tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TerrainProvider} terrainProvider The terrain provider associated with the terrain tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} insertionPoint The position to insert new skeletons before in the tile&#39;s imagery list.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Boolean} true if this layer overlaps any portion of the terrain tile; otherwise, false.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;ImageryLayer.prototype._createTileImagerySkeletons = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; terrainProvider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; insertionPoint&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var surfaceTile = tile.data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(this._minimumTerrainLevel) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.level &amp;lt; this._minimumTerrainLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(this._maximumTerrainLevel) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.level &amp;gt; this._maximumTerrainLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var imageryProvider = this._imageryProvider;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(insertionPoint)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; insertionPoint = surfaceTile.imagery.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!imageryProvider.ready) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // The imagery provider is not ready, so we can&#39;t create skeletons, yet.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Instead, add a placeholder so that we&#39;ll know to create&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // the skeletons once the provider is ready.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._skeletonPlaceholder.loadingImagery.addReference();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; surfaceTile.imagery.splice(insertionPoint, 0, this._skeletonPlaceholder);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Use Web Mercator for our texture coordinate computations if this imagery layer uses&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // that projection and the terrain tile falls entirely inside the valid bounds of the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // projection.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var useWebMercatorT =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryProvider.tilingScheme.projection instanceof WebMercatorProjection &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.rectangle.north &amp;lt; WebMercatorProjection.MaximumLatitude &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.rectangle.south &amp;gt; -WebMercatorProjection.MaximumLatitude;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Compute the rectangle of the imagery from this imageryProvider that overlaps&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // the geometry tile.&amp;nbsp; The ImageryProvider and ImageryLayer both have the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // opportunity to constrain the rectangle.&amp;nbsp; The imagery TilingScheme&#39;s rectangle&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // always fully contains the ImageryProvider&#39;s rectangle.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var imageryBounds = Rectangle.intersection(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryProvider.rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryBoundsScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var rectangle = Rectangle.intersection(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryBounds,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileImageryBoundsScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(rectangle)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // There is no overlap between this terrain tile and this imagery&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // provider.&amp;nbsp; Unless this is the base layer, no skeletons need to be created.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // We stretch texels at the edge of the base layer over the entire globe.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!this.isBaseLayer()) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var baseImageryRectangle = imageryBounds;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var baseTerrainRectangle = tile.rectangle;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; rectangle = tileImageryBoundsScratch;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (baseTerrainRectangle.south &amp;gt;= baseImageryRectangle.north) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle.north = rectangle.south = baseImageryRectangle.north;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else if (baseTerrainRectangle.north &amp;lt;= baseImageryRectangle.south) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle.north = rectangle.south = baseImageryRectangle.south;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle.south = Math.max(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; baseTerrainRectangle.south,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; baseImageryRectangle.south&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle.north = Math.min(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; baseTerrainRectangle.north,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; baseImageryRectangle.north&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (baseTerrainRectangle.west &amp;gt;= baseImageryRectangle.east) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle.west = rectangle.east = baseImageryRectangle.east;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else if (baseTerrainRectangle.east &amp;lt;= baseImageryRectangle.west) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle.west = rectangle.east = baseImageryRectangle.west;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle.west = Math.max(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; baseTerrainRectangle.west,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; baseImageryRectangle.west&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle.east = Math.min(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; baseTerrainRectangle.east,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; baseImageryRectangle.east&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var latitudeClosestToEquator = 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (rectangle.south &amp;gt; 0.0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; latitudeClosestToEquator = rectangle.south;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else if (rectangle.north &amp;lt; 0.0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; latitudeClosestToEquator = rectangle.north;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Compute the required level in the imagery tiling scheme.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // The errorRatio should really be imagerySSE / terrainSSE rather than this hard-coded value.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // But first we need configurable imagery SSE and we need the rendering to be able to handle more&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // images attached to a terrain tile than there are available texture units.&amp;nbsp; So that&#39;s for the future.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var errorRatio = 1.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var targetGeometricError =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; errorRatio * terrainProvider.getLevelMaximumGeometricError(tile.level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var imageryLevel = getLevelWithMaximumTexelSpacing(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; targetGeometricError,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; latitudeClosestToEquator&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; imageryLevel = Math.max(0, imageryLevel);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var maximumLevel = imageryProvider.maximumLevel;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (imageryLevel &amp;gt; maximumLevel) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryLevel = maximumLevel;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(imageryProvider.minimumLevel)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var minimumLevel = imageryProvider.minimumLevel;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (imageryLevel &amp;lt; minimumLevel) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryLevel = minimumLevel;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var imageryTilingScheme = imageryProvider.tilingScheme;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var northwestTileCoordinates = imageryTilingScheme.positionToTileXY(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Rectangle.northwest(rectangle),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var southeastTileCoordinates = imageryTilingScheme.positionToTileXY(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Rectangle.southeast(rectangle),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // If the southeast corner of the rectangle lies very close to the north or west side&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // of the southeast tile, we don&#39;t actually need the southernmost or easternmost&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // tiles.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Similarly, if the northwest corner of the rectangle lies very close to the south or east side&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // of the northwest tile, we don&#39;t actually need the northernmost or westernmost tiles.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // We define &quot;very close&quot; as being within 1/512 of the width of the tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var veryCloseX = tile.rectangle.width / 512.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var veryCloseY = tile.rectangle.height / 512.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var northwestTileRectangle = imageryTilingScheme.tileXYToRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; northwestTileCoordinates.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; northwestTileCoordinates.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Math.abs(northwestTileRectangle.south - tile.rectangle.north) &amp;lt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; veryCloseY &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; northwestTileCoordinates.y &amp;lt; southeastTileCoordinates.y&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ++northwestTileCoordinates.y;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Math.abs(northwestTileRectangle.east - tile.rectangle.west) &amp;lt; veryCloseX &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; northwestTileCoordinates.x &amp;lt; southeastTileCoordinates.x&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ++northwestTileCoordinates.x;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var southeastTileRectangle = imageryTilingScheme.tileXYToRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; southeastTileCoordinates.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; southeastTileCoordinates.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Math.abs(southeastTileRectangle.north - tile.rectangle.south) &amp;lt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; veryCloseY &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; southeastTileCoordinates.y &amp;gt; northwestTileCoordinates.y&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; --southeastTileCoordinates.y;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Math.abs(southeastTileRectangle.west - tile.rectangle.east) &amp;lt; veryCloseX &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; southeastTileCoordinates.x &amp;gt; northwestTileCoordinates.x&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; --southeastTileCoordinates.x;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Create TileImagery instances for each imagery tile overlapping this terrain tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // We need to do all texture coordinate computations in the imagery tile&#39;s tiling scheme.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainRectangle = Rectangle.clone(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tile.rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainRectangleScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var imageryRectangle = imageryTilingScheme.tileXYToRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; northwestTileCoordinates.x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; northwestTileCoordinates.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var clippedImageryRectangle = Rectangle.intersection(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryBounds,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; clippedRectangleScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var imageryTileXYToRectangle;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (useWebMercatorT) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryTilingScheme.rectangleToNativeRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainRectangle&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryTilingScheme.rectangleToNativeRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryRectangle&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryTilingScheme.rectangleToNativeRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; clippedImageryRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; clippedImageryRectangle&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryTilingScheme.rectangleToNativeRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryBounds,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryBounds&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryTileXYToRectangle = imageryTilingScheme.tileXYToNativeRectangle.bind(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryTilingScheme&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; veryCloseX = terrainRectangle.width / 512.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; veryCloseY = terrainRectangle.height / 512.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryTileXYToRectangle = imageryTilingScheme.tileXYToRectangle.bind(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryTilingScheme&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var minU;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var maxU = 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var minV = 1.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var maxV;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // If this is the northern-most or western-most tile in the imagery tiling scheme,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // it may not start at the northern or western edge of the terrain tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Calculate where it does start.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !this.isBaseLayer() &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Math.abs(clippedImageryRectangle.west - terrainRectangle.west) &amp;gt;= veryCloseX&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; maxU = Math.min(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 1.0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; (clippedImageryRectangle.west - terrainRectangle.west) /&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; terrainRectangle.width&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !this.isBaseLayer() &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; Math.abs(clippedImageryRectangle.north - terrainRectangle.north) &amp;gt;=&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; veryCloseY&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; minV = Math.max(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 0.0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; (clippedImageryRectangle.north - terrainRectangle.south) /&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; terrainRectangle.height&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var initialMinV = minV;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var i = northwestTileCoordinates.x;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; i &amp;lt;= southeastTileCoordinates.x;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; i++&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; minU = maxU;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; imageryRectangle = imageryTileXYToRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; i,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; northwestTileCoordinates.y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; clippedImageryRectangle = Rectangle.simpleIntersection(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryBounds,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; clippedRectangleScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (!defined(clippedImageryRectangle)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; continue;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; maxU = Math.min(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 1.0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; (clippedImageryRectangle.east - terrainRectangle.west) /&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; terrainRectangle.width&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // If this is the eastern-most imagery tile mapped to this terrain tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // and there are more imagery tiles to the east of this one, the maxU&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // should be 1.0 to make sure rounding errors don&#39;t make the last&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // image fall shy of the edge of the terrain tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; i === southeastTileCoordinates.x &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; (this.isBaseLayer() ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Math.abs(clippedImageryRectangle.east - terrainRectangle.east) &amp;lt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; veryCloseX)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; maxU = 1.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; minV = initialMinV;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var j = northwestTileCoordinates.y;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; j &amp;lt;= southeastTileCoordinates.y;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; j++&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; maxV = minV;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; imageryRectangle = imageryTileXYToRectangle(i, j, imageryLevel);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; clippedImageryRectangle = Rectangle.simpleIntersection(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; imageryRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; imageryBounds,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; clippedRectangleScratch&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (!defined(clippedImageryRectangle)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; continue;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; minV = Math.max(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 0.0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (clippedImageryRectangle.south - terrainRectangle.south) /&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; terrainRectangle.height&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // If this is the southern-most imagery tile mapped to this terrain tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // and there are more imagery tiles to the south of this one, the minV&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // should be 0.0 to make sure rounding errors don&#39;t make the last&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // image fall shy of the edge of the terrain tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; j === southeastTileCoordinates.y &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; (this.isBaseLayer() ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Math.abs(clippedImageryRectangle.south - terrainRectangle.south) &amp;lt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; veryCloseY)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; minV = 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var texCoordsRectangle = new Cartesian4(minU, minV, maxU, maxV);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var imagery = this.getImageryFromCache(i, j, imageryLevel);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; surfaceTile.imagery.splice(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; insertionPoint,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; 0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; new TileImagery(imagery, texCoordsRectangle, useWebMercatorT)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ++insertionPoint;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-98" vertex="1">
          <mxGeometry x="53" y="1840" width="613" height="5280" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-65" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Updates frame state to execute any queued texture re-projections.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The frameState.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;ImageryLayer.prototype.queueReprojectionCommands = function (frameState) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var computeCommands = this._reprojectComputeCommands;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var length = computeCommands.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var i = 0; i &amp;lt; length; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; frameState.commandList.push(computeCommands[i]);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; computeCommands.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_qH6-IZlokEgzrvQ4-RS-98" vertex="1">
          <mxGeometry x="21" y="230" width="478" height="240" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-107" style="orthogonalLoop=1;jettySize=auto;html=1;startSize=40;strokeColor=#000000;fontSize=25;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-106" target="_qH6-IZlokEgzrvQ4-RS-99" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-6" style="orthogonalLoop=1;jettySize=auto;html=1;sketch=0;" parent="1" source="xKLGjb7A9fxTzqLFo98r-5" target="xKLGjb7A9fxTzqLFo98r-4" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-9" style="orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="xKLGjb7A9fxTzqLFo98r-8" target="xKLGjb7A9fxTzqLFo98r-7" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-36" value="ImageryLayerCollection.js" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=100;startSize=146;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="9128" y="-514" width="1386" height="1012" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-37" value="&lt;div&gt;&lt;b&gt;ImageryLayerCollection.prototype._update = function () {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var isBaseLayer = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var layers = this._layers;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var layersShownOrHidden;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var layer;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var i, len;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (i = 0, len = layers.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; layer = layers[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; layer._layerIndex = i;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;b&gt;&lt;br&gt;&amp;nbsp; &amp;nbsp; // 如果遇到第一个显示的图层，则将其 isBaseLayer 设为 true，其他的设为 false&lt;/b&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (layer.show) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layer._isBaseLayer = isBaseLayer;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; isBaseLayer = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layer._isBaseLayer = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 在 layersShownOrHidden 中记录需要切换显隐的图层&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (layer.show !== layer._show) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (defined(layer._show)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (!defined(layersShownOrHidden)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; layersShownOrHidden = [];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; layersShownOrHidden.push(layer);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layer._show = layer.show;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 切换 layersShownOrHidden 中图层的显隐&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(layersShownOrHidden)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (i = 0, len = layersShownOrHidden.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layer = layersShownOrHidden[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this.layerShownOrHidden.raiseEvent(layer, layer._layerIndex, layer.show);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="xKLGjb7A9fxTzqLFo98r-36" vertex="1">
          <mxGeometry x="36.5" y="168" width="467" height="562" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-60" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Updates frame state to execute any queued texture re-projections.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {FrameState} frameState The frameState.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;ImageryLayerCollection.prototype.queueReprojectionCommands = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameState&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var layers = this._layers;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var i = 0, len = layers.length; i &amp;lt; len; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; layers[i].queueReprojectionCommands(frameState);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="xKLGjb7A9fxTzqLFo98r-36" vertex="1">
          <mxGeometry x="41.5" y="761" width="462" height="226" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-66" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;align=left;" parent="xKLGjb7A9fxTzqLFo98r-60" vertex="1">
          <mxGeometry x="323" y="183" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-40" style="orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="xKLGjb7A9fxTzqLFo98r-39" target="xKLGjb7A9fxTzqLFo98r-37" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-53" style="orthogonalLoop=1;jettySize=auto;html=1;sketch=0;edgeStyle=orthogonalEdgeStyle;" parent="1" source="xKLGjb7A9fxTzqLFo98r-50" target="xKLGjb7A9fxTzqLFo98r-51" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="-1503" y="1048" as="targetPoint" />
            <Array as="points">
              <mxPoint x="-1257" y="779" />
              <mxPoint x="-1257" y="779" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-56" style="orthogonalLoop=1;jettySize=auto;html=1;edgeStyle=orthogonalEdgeStyle;" parent="1" source="xKLGjb7A9fxTzqLFo98r-55" target="xKLGjb7A9fxTzqLFo98r-54" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="206" y="1048" />
              <mxPoint x="206" y="-21" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-62" style="orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="xKLGjb7A9fxTzqLFo98r-61" target="xKLGjb7A9fxTzqLFo98r-60" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-67" style="orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="xKLGjb7A9fxTzqLFo98r-66" target="xKLGjb7A9fxTzqLFo98r-65" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="10952" y="1596.666666666667" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-35" style="edgeStyle=orthogonalEdgeStyle;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-34" target="_K7aeOZNzX8ZAruB3Fqv-32" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="-517" y="1437" />
              <mxPoint x="-517" y="1437" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-38" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-37" target="_K7aeOZNzX8ZAruB3Fqv-36" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-45" value="QuadtreePrimitive.js" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="975" y="-1362" width="1133" height="547" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-46" value="&lt;b&gt;this._tilesToRender = [ ]&lt;/b&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;collapsible=0;comic=0;rotatable=0;fillColor=#FFD966;" parent="_K7aeOZNzX8ZAruB3Fqv-45" vertex="1">
          <mxGeometry x="68" y="271" width="157" height="30" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-52" value="&lt;b&gt;this._levelZeroTiles = undefined&lt;/b&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;collapsible=0;comic=0;rotatable=0;fillColor=#FFD966;" parent="_K7aeOZNzX8ZAruB3Fqv-45" vertex="1">
          <mxGeometry x="288" y="271" width="204" height="30" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-58" value="&lt;b&gt;rootTraversalDetails = [ ]; // 根节点瓦片附加信息&lt;br&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // 其中储存的是 TraversalDetails 类型&lt;/b&gt;&lt;br&gt;&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Tracks details of traversing a tile while selecting tiles for rendering.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @alias TraversalDetails&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @constructor&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;function TraversalDetails() {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 所有子树中的 selected (非 culled 或 refined) 瓦片都可渲染&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.allAreRenderable = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 子树中的任何瓦片在上一帧中被渲染。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 如果存在，则不渲染该瓦片而渲染子树，否则会导致已渲染的变模糊&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.anyWereRenderedLastFrame = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 子树中还没准备好渲染的瓦片数量。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // allAreRenderable 为 ture 时，该&lt;/b&gt;&lt;b&gt;值不需要必须为 0。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 当 allAreRenderable 和 anyWereRenderedLastFrame 都为 false 时，&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 则渲染当前瓦片而不是子瓦片。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // notYetRenderableCount 仅在子树从渲染队列中移除时进行重置&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.notYetRenderableCount = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;collapsible=0;comic=0;rotatable=0;fillColor=#FFD966;" parent="_K7aeOZNzX8ZAruB3Fqv-45" vertex="1">
          <mxGeometry x="581" y="180" width="423" height="338" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-50" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;dashed=1;dashPattern=1 4;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-49" target="_K7aeOZNzX8ZAruB3Fqv-46" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-54" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;dashed=1;strokeWidth=1;dashPattern=1 4;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-53" target="_K7aeOZNzX8ZAruB3Fqv-52" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-60" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;dashed=1;strokeWidth=1;dashPattern=1 4;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-59" target="_K7aeOZNzX8ZAruB3Fqv-58" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="1134.8823529411766" y="305.1764705882356" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-61" value="QuadtreeTile.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=135;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="4633" y="933" width="878" height="3386" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-62" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Creates a rectangular set of tiles for level of detail zero, the coarsest, least detailed level.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @memberof QuadtreeTile&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TilingScheme} tilingScheme The tiling scheme for which the tiles are to be created.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {QuadtreeTile[]} An array containing the tiles at level of detail zero, starting with the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* tile in the northwest corner and followed by the tile (if any) to its east.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;QuadtreeTile.createLevelZeroTiles = function (tilingScheme) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeStart(&#39;debug&#39;, pragmas.debug);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(tilingScheme)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;tilingScheme is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeEnd(&#39;debug&#39;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var numberOfLevelZeroTilesX = tilingScheme.getNumberOfXTilesAtLevel(0);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var numberOfLevelZeroTilesY = tilingScheme.getNumberOfYTilesAtLevel(0);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var result = new Array(numberOfLevelZeroTilesX * numberOfLevelZeroTilesY);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var index = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var y = 0; y &amp;lt; numberOfLevelZeroTilesY; ++y) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (var x = 0; x &amp;lt; numberOfLevelZeroTilesX; ++x) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result[index++] = new QuadtreeTile({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; tilingScheme: tilingScheme,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; x: x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; y: y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; level: 0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return result;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-61" vertex="1">
          <mxGeometry x="41" y="153" width="565" height="506" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-69" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-62" vertex="1">
          <mxGeometry x="454" y="238" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-71" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-62" vertex="1">
          <mxGeometry x="454" y="251" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-85" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;dashed=1;sketch=0;" parent="_K7aeOZNzX8ZAruB3Fqv-62" vertex="1">
          <mxGeometry x="242" y="351" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-83" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* A single tile in a {@link QuadtreePrimitive}.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @alias QuadtreeTile&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @constructor&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} options.level The level of the tile in the quadtree.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} options.x The X coordinate of the tile in the quadtree.&amp;nbsp; 0 is the westernmost tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} options.y The Y coordinate of the tile in the quadtree.&amp;nbsp; 0 is the northernmost tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TilingScheme} options.tilingScheme The tiling scheme in which this tile exists.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {QuadtreeTile} [options.parent] This tile&#39;s parent, or undefined if this is a root tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;function QuadtreeTile(options) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeStart(&#39;debug&#39;, pragmas.debug);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(options)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;options is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(options.x)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;options.x is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else if (!defined(options.y)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;options.y is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else if (options.x &amp;lt; 0 || options.y &amp;lt; 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;options.x and options.y must be greater than or equal to zero.&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(options.level)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;options.level is required and must be greater than or equal to zero.&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(options.tilingScheme)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;options.tilingScheme is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeEnd(&#39;debug&#39;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._tilingScheme = options.tilingScheme;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._x = options.x;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._y = options.y;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._level = options.level;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._parent = options.parent;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 将瓦片序号和级别转换为经纬度举型，单位为弧度&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 底层两个瓦片范围为 {east: pi, north: pi/2, south: -pi/2, west: 0}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 和 {east: 0, north: pi/2, south: -pi/2, west: pi}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._rectangle = this._tilingScheme.tileXYToRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._level&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._southwestChild = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._southeastChild = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._northwestChild = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._northeastChild = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // TileReplacementQueue gets/sets these private properties.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.replacementPrevious = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.replacementNext = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 瓦片到摄像机的距离, updated when the tile is selected&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // for rendering.&amp;nbsp; We can get rid of this if we have a better way to sort by&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // distance - for example, by using the natural ordering of a quadtree.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // QuadtreePrimitive gets/sets this private property.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._distance = 0.0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._loadPriority = 0.0; // 加载优先级&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._customData = [];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._frameUpdated = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._lastSelectionResult = TileSelectionResult.NONE;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._lastSelectionResultFrame = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._loadedCallbacks = {};&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; /**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* Gets or sets the current state of the tile in the tile load pipeline.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* @type {QuadtreeTileLoadState}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* @default {@link QuadtreeTileLoadState.START}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 加载状态，包括 START、LOADING、DONE 和 FAILED&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.state = QuadtreeTileLoadState.START;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; /**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* Gets or sets a value indicating whether or not the tile is currently renderable.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* @type {Boolean}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* @default false&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.renderable = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; /**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* Gets or set a value indicating whether or not the tile was entirely upsampled from its&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* parent tile.&amp;nbsp; If all four children of a parent tile were upsampled from the parent,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* we will render the parent instead of the children even if the LOD indicates that&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* the children would be preferable.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* @type {Boolean}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* @default false&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 瓦片是否是通过父级采样得到的，如果四个兄弟瓦片都是上采样得到的，则渲染父瓦片&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.upsampledFromParent = false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; /**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* Gets or sets the additional data associated with this tile.&amp;nbsp; The exact content is specific to the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* {@link QuadtreeTileProvider}.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* @type {Object}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;* @default undefined&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 瓦片的附加信息&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.data = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-61" vertex="1">
          <mxGeometry x="41" y="711" width="599" height="1528" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-86" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=1;" parent="_K7aeOZNzX8ZAruB3Fqv-61" source="_K7aeOZNzX8ZAruB3Fqv-85" target="_K7aeOZNzX8ZAruB3Fqv-83" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-31" value="&lt;div&gt;&lt;b&gt;QuadtreeTile.prototype._updateCustomData = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; frameNumber,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; added,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; removed&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var customData = this.customData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var i;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var data;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var rectangle;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(added) &amp;amp;&amp;amp; defined(removed)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; customData = customData.filter(function (value) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return removed.indexOf(value) === -1;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._customData = customData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; rectangle = this._rectangle;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (i = 0; i &amp;lt; added.length; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; data = added[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (Rectangle.contains(rectangle, data.positionCartographic)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; customData.push(data);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._frameUpdated = frameNumber;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // interior or leaf tile, update from parent&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var parent = this._parent;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(parent) &amp;amp;&amp;amp; this._frameUpdated !== parent._frameUpdated) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; customData.length = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rectangle = this._rectangle;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var parentCustomData = parent.customData;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; for (i = 0; i &amp;lt; parentCustomData.length; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; data = parentCustomData[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (Rectangle.contains(rectangle, data.positionCartographic)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; customData.push(data);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this._frameUpdated = parent._frameUpdated;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-61" vertex="1">
          <mxGeometry x="41" y="2690" width="437" height="646" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-64" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-53" target="_K7aeOZNzX8ZAruB3Fqv-62" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="2013" y="814" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-78" value="TilingScheme" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=135;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="5787" y="1093" width="898" height="1220" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-65" value="GeographicTilingScheme.js" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=25;startSize=40;fontStyle=1;autosize=0;collapsible=1;expand=1;" parent="_K7aeOZNzX8ZAruB3Fqv-78" vertex="1">
          <mxGeometry x="24" y="279" width="520" height="377" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-66" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Gets the total number of tiles in the X direction at a specified level-of-detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level-of-detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} The number of tiles in the X direction at the given level.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // _numberOfLevelZeroTilesX 的默认值是 2&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return this._numberOfLevelZeroTilesX &amp;lt;&amp;lt; level; // 移位运算符&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-65" vertex="1">
          <mxGeometry x="13" y="48" width="491" height="156" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-67" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Gets the total number of tiles in the Y direction at a specified level-of-detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level-of-detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} The number of tiles in the Y direction at the given level.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // _numberOfLevelZeroTilesY 的默认值是 1&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return this._numberOfLevelZeroTilesY &amp;lt;&amp;lt; level; // 移位运算符&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-65" vertex="1">
          <mxGeometry x="13" y="211" width="491" height="156" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-73" value="WebMercatorTilingScheme.js" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=25;startSize=40;fontStyle=1;autosize=0;collapsible=1;expand=1;" parent="_K7aeOZNzX8ZAruB3Fqv-78" vertex="1">
          <mxGeometry x="22" y="701" width="520" height="394" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-74" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Gets the total number of tiles in the X direction at a specified level-of-detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level-of-detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} The number of tiles in the X direction at the given level.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;WebMercatorTilingScheme.prototype.getNumberOfXTilesAtLevel = function (level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // _numberOfLevelZeroTilesX 的默认值为 1&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return this._numberOfLevelZeroTilesX &amp;lt;&amp;lt; level; // 移位运算符&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-73" vertex="1">
          <mxGeometry x="13" y="48" width="500" height="156" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-75" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Gets the total number of tiles in the Y direction at a specified level-of-detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level-of-detail.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} The number of tiles in the Y direction at the given level.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;WebMercatorTilingScheme.prototype.getNumberOfYTilesAtLevel = function (level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // _numberOfLevelZeroTilesY 的默认值为 1&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return this._numberOfLevelZeroTilesY &amp;lt;&amp;lt; level; // 移位运算符&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-73" vertex="1">
          <mxGeometry x="13" y="219" width="500" height="156" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-81" value="&lt;div&gt;&lt;b&gt;tilingScheme 的类型包括 GeographicTilingScheme 和 WebMercatorTilingScheme，&lt;/b&gt;&lt;b&gt;在 TerrainProvider 的构造函数中决定。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;EllipsoidTerrainProvider 支持 GeographicTilingScheme&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;CesiumTerrainProvider 根据投影类型支持 GeographicTilingScheme - EPSG:4326，WebMercatorTilingScheme - EPSG:3857&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;ArcGisTiledElevationTerrainProvider 根据投影类型支持 GeographicTilingScheme - EPSG:4326，WebMercatorTilingScheme - EPSG:3857&lt;/b&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;GoogleEarthEnterpriseTerrainProvider 支持 GeographicTilingScheme，底层瓦片为 2×2&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-78" vertex="1">
          <mxGeometry x="22" y="147" width="793" height="86" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-63" style="orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#000000;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-61" target="_qH6-IZlokEgzrvQ4-RS-77" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="2450" y="2060" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="w7j-vH0q7G85GLxAOJQ2-22" style="orthogonalLoop=1;jettySize=auto;html=1;dashed=1;fillColor=#ffff88;strokeWidth=1;dashPattern=1 4;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-38" target="_qH6-IZlokEgzrvQ4-RS-27" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-103" value="TileReplacementQueue.js" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="4135" y="6110" width="1752" height="1101" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-102" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Marks the start of the render frame.&amp;nbsp; Tiles before (closer to the head) this tile in the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* list were used last frame and must not be unloaded.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;TileReplacementQueue.prototype.markStartOfRenderFrame = function () {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._lastBeforeStartOfFrame = this.head;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-103" vertex="1">
          <mxGeometry x="624" y="488" width="515" height="114" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-73" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Marks a tile as rendered this frame and moves it before the first tile that was not rendered&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* this frame.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TileReplacementQueue} item The tile that was rendered.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;TileReplacementQueue.prototype.markTileRendered = function (item) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var head = this.head;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (head === item) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (item === this._lastBeforeStartOfFrame) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; this._lastBeforeStartOfFrame = item.replacementNext;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 无论链表中是否存在，都增加个数&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ++this.count;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(head)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // 列表为空&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; item.replacementPrevious = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; item.replacementNext = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this.head = item;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this.tail = item;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 如果链表中已经存在，则在链表中移除，个数减一，在下方重新插入&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (defined(item.replacementPrevious) || defined(item.replacementNext)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // tile already in the list, remove from its current location&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; remove(this, item);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;&amp;nbsp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // 插入至链表头&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; item.replacementPrevious = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; item.replacementNext = head;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; head.replacementPrevious = item;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.head = item;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=1;autosize=0;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-103" vertex="1">
          <mxGeometry x="43" y="477" width="543" height="580" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-132" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;sketch=0;fontSize=75;align=center;" parent="_qH6-IZlokEgzrvQ4-RS-73" vertex="1">
          <mxGeometry x="133" y="433.99642335766424" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-89" value="&lt;div&gt;&lt;b&gt;// 一个双向链表，其中存储的元素是 QuadtreeTile 类型。&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;// QuadtreeTile 包含两个与该列表有关的属性 replacementNext 和 replacementPrevious&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* A priority queue of tiles to be replaced, if necessary, to make room for new tiles.&amp;nbsp; The queue&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* is implemented as a linked list.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @alias TileReplacementQueue&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;function TileReplacementQueue() {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.head = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.tail = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this.count = 0;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._lastBeforeStartOfFrame = undefined; // 上一帧的 head&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-103" vertex="1">
          <mxGeometry x="624" y="172" width="555" height="226" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-131" value="&lt;div&gt;&lt;b&gt;function remove(tileReplacementQueue, item) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var previous = item.replacementPrevious;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var next = item.replacementNext;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (item === tileReplacementQueue._lastBeforeStartOfFrame) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileReplacementQueue._lastBeforeStartOfFrame = next;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (item === tileReplacementQueue.head) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileReplacementQueue.head = next;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; previous.replacementNext = next;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (item === tileReplacementQueue.tail) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileReplacementQueue.tail = previous;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; next.replacementPrevious = previous;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; item.replacementPrevious = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; item.replacementNext = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; --tileReplacementQueue.count;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-103" vertex="1">
          <mxGeometry x="622" y="696" width="382" height="366" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-133" style="edgeStyle=none;rounded=1;sketch=0;jumpStyle=none;orthogonalLoop=1;jettySize=auto;html=1;fontSize=75;" parent="_K7aeOZNzX8ZAruB3Fqv-103" source="_K7aeOZNzX8ZAruB3Fqv-132" target="_K7aeOZNzX8ZAruB3Fqv-131" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-135" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Marks the start of the render frame.&amp;nbsp; Tiles before (closer to the head) this tile in the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* list were used last frame and must not be unloaded.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;TileReplacementQueue.prototype.markStartOfRenderFrame = function () {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._lastBeforeStartOfFrame = this.head;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-103" vertex="1">
          <mxGeometry x="43" y="234" width="503" height="114" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-136" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Reduces the size of the queue to a specified size by unloading the least-recently used&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* tiles.&amp;nbsp; Tiles that were used last frame will not be unloaded, even if that puts the number&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* of tiles above the specified maximum.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} maximumTiles The maximum number of tiles in the queue.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;TileReplacementQueue.prototype.trimTiles = function (maximumTiles) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var tileToTrim = this.tail;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var keepTrimming = true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; while (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; keepTrimming &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(this._lastBeforeStartOfFrame) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this.count &amp;gt; maximumTiles &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(tileToTrim)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Stop trimming after we process the last tile not used in the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // current frame.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; keepTrimming = tileToTrim !== this._lastBeforeStartOfFrame;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var previous = tileToTrim.replacementPrevious;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (tileToTrim.eligibleForUnloading) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; tileToTrim.freeResources();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; remove(this, tileToTrim);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tileToTrim = previous;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="_K7aeOZNzX8ZAruB3Fqv-103" vertex="1">
          <mxGeometry x="1172" y="504" width="528" height="436" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-41" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-40" target="_K7aeOZNzX8ZAruB3Fqv-39" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-59" style="orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="xKLGjb7A9fxTzqLFo98r-58" target="xKLGjb7A9fxTzqLFo98r-57" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="xKLGjb7A9fxTzqLFo98r-35" style="orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="xKLGjb7A9fxTzqLFo98r-34" target="xKLGjb7A9fxTzqLFo98r-32" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-70" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=1;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-69" target="_K7aeOZNzX8ZAruB3Fqv-66" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-72" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=1;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-71" target="_K7aeOZNzX8ZAruB3Fqv-67" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-19" style="orthogonalLoop=1;jettySize=auto;html=1;strokeColor=#000000;edgeStyle=orthogonalEdgeStyle;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-18" target="_qH6-IZlokEgzrvQ4-RS-17" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="-3042" y="-286" />
              <mxPoint x="-3042" y="316" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-77" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=1;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-71" target="_K7aeOZNzX8ZAruB3Fqv-75" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-76" style="edgeStyle=none;orthogonalLoop=1;jettySize=auto;html=1;strokeWidth=1;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-69" target="_K7aeOZNzX8ZAruB3Fqv-74" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-75" style="orthogonalLoop=1;jettySize=auto;html=1;startSize=40;strokeColor=#000000;fontSize=25;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-60" target="_qH6-IZlokEgzrvQ4-RS-73" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="_K7aeOZNzX8ZAruB3Fqv-137" style="rounded=1;sketch=0;jumpStyle=none;orthogonalLoop=1;jettySize=auto;html=1;fontSize=75;" parent="1" source="_K7aeOZNzX8ZAruB3Fqv-134" target="_K7aeOZNzX8ZAruB3Fqv-135" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-3" style="rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="O9qtJ-ZTzyiBhBGTBMVZ-1" target="O9qtJ-ZTzyiBhBGTBMVZ-2" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="2571.3529411764703" y="3219.2941176470586" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-22" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="O9qtJ-ZTzyiBhBGTBMVZ-21" target="O9qtJ-ZTzyiBhBGTBMVZ-20" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-34" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="O9qtJ-ZTzyiBhBGTBMVZ-32" target="O9qtJ-ZTzyiBhBGTBMVZ-31" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-41" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="O9qtJ-ZTzyiBhBGTBMVZ-39" target="O9qtJ-ZTzyiBhBGTBMVZ-40" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="3561.333333333334" y="4685" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-46" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="O9qtJ-ZTzyiBhBGTBMVZ-45" target="zrCMIupTtKye5h8rk7Vh-308" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="13465" y="4093" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-49" value="TerrainProvider" style="swimlane;swimlaneLine=1;swimlaneFillColor=none;fontSize=100;startSize=146;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" parent="1" vertex="1">
          <mxGeometry x="11703" y="3230" width="2059" height="3851" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-303" value="" style="shape=table;html=1;whiteSpace=wrap;startSize=0;container=1;collapsible=0;childLayout=tableLayout;shadow=0;strokeWidth=3;perimeterSpacing=0;swimlaneFillColor=none;rowLines=1;columnLines=1;fixedRows=0;horizontal=0;strokeColor=#666666;fontColor=#333333;fillColor=#CCFFFF;" vertex="1" parent="O9qtJ-ZTzyiBhBGTBMVZ-49">
          <mxGeometry x="157" y="900" width="1630" height="2829.43137254902" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-308" value="" style="shape=partialRectangle;html=1;whiteSpace=wrap;collapsible=0;dropTarget=0;pointerEvents=0;top=0;left=0;bottom=0;right=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;strokeWidth=1;fillColor=none;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-303">
          <mxGeometry width="1630" height="282" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-309" value="&lt;div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Note: the 64 below does NOT need to match the actual vertex dimensions, because&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // the ellipsoid is significantly smoother than actual terrain.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._tilingScheme.ellipsoid,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; 64,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._tilingScheme.getNumberOfXTilesAtLevel(0)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Gets the maximum geometric error allowed in a tile at a given level.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The tile level for which to get the maximum geometric error.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} The maximum geometric error.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;EllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; level&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return this._levelZeroMaximumGeometricError / (1 &amp;lt;&amp;lt; level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;top=0;left=0;bottom=0;right=0;overflow=hidden;rounded=0;align=left;verticalAlign=top;spacing=6;strokeWidth=1;fillColor=none;container=1;collapsible=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-308">
          <mxGeometry width="686" height="282" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-380" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-309">
          <mxGeometry x="664" y="43" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-344" value="&lt;div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._tilingScheme.ellipsoid,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._heightmapWidth,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._tilingScheme.getNumberOfXTilesAtLevel(0)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Gets the maximum geometric error allowed in a tile at a given level.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The tile level for which to get the maximum geometric error.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} The maximum geometric error.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;EllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; level&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return this._levelZeroMaximumGeometricError / (1 &amp;lt;&amp;lt; level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;br&gt;&lt;/div&gt;" style="shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;top=0;left=0;bottom=0;right=0;overflow=hidden;rounded=0;align=left;verticalAlign=top;spacing=6;fillColor=none;container=1;collapsible=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-308">
          <mxGeometry x="686" width="944" height="282" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-381" value="" style="whiteSpace=wrap;html=1;aspect=fixed;fillColor=#000000;strokeColor=none;shadow=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-344">
          <mxGeometry x="672" y="15" width="8" height="8" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-304" value="" style="shape=partialRectangle;html=1;whiteSpace=wrap;collapsible=0;dropTarget=0;pointerEvents=0;fillColor=none;top=0;left=0;bottom=0;right=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;strokeWidth=1;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-303">
          <mxGeometry y="282" width="1630" height="549" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-305" value="&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp;* Determines whether data for a tile is available to be loaded.&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp;* @param {Number} x The X coordinate of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp;* @param {Number} y The Y coordinate of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp;* @returns {Boolean} Undefined if not supported, otherwise true or false.&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;EllipsoidTerrainProvider.prototype.getTileDataAvailable = function (&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp; level&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;&amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div style=&quot;text-align: left&quot;&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;top=0;left=0;bottom=0;right=0;overflow=hidden;rounded=0;align=left;verticalAlign=top;spacing=6;fillColor=none;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-304">
          <mxGeometry width="686" height="549" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-343" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Determines whether data for a tile is available to be loaded.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} x The X coordinate of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} y The Y coordinate of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Boolean} Undefined if not supported or availability is unknown, otherwise true or false.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;CesiumTerrainProvider.prototype.getTileDataAvailable = function (x, y, level) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(this._availability)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (level &amp;gt; this._availability._maximumLevel) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (this._availability.isTileAvailable(level, x, y)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // If the tile is listed as available, then we are done&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return true;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!this._hasMetadata) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // If we don&#39;t have any layers with the metadata extension then we don&#39;t have this tile&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var layers = this._layers;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var count = layers.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var i = 0; i &amp;lt; count; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var layerResult = checkLayer(this, x, y, level, layers[i], i === 0);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (layerResult.result) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // There is a layer that may or may not have the tile&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return false;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;top=0;left=0;bottom=0;right=0;overflow=hidden;rounded=0;align=left;verticalAlign=top;spacing=6;fillColor=none;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-304">
          <mxGeometry x="686" width="944" height="549" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-383" style="shape=partialRectangle;html=1;whiteSpace=wrap;collapsible=0;dropTarget=0;pointerEvents=0;fillColor=none;top=0;left=0;bottom=0;right=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;strokeWidth=1;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-303">
          <mxGeometry y="831" width="1630" height="765" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-384" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Requests the geometry for a given tile.&amp;nbsp; This function should not be called before&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* {@link TerrainProvider#ready} returns true.&amp;nbsp; The result includes terrain&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* data and indicates that all child tiles are available.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} x The X coordinate of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} y The Y coordinate of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Request} [request] The request object. Intended for internal use only.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Promise.&amp;lt;TerrainData&amp;gt;|undefined} A promise for the requested geometry.&amp;nbsp; If this method&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; returns undefined instead of a promise, it is an indication that too many requests are already&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pending and the request will be retried later.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;EllipsoidTerrainProvider.prototype.requestTileGeometry = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; request&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var width = 16;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var height = 16;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return when.resolve(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; new HeightmapTerrainData({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; buffer: new Uint8Array(width * height),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; width: width,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; height: height,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; })&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;top=0;left=0;bottom=0;right=0;overflow=hidden;rounded=0;align=left;verticalAlign=top;spacing=6;fillColor=none;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-383">
          <mxGeometry width="686" height="765" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-385" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Requests the geometry for a given tile.&amp;nbsp; This function should not be called before&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* {@link CesiumTerrainProvider#ready} returns true.&amp;nbsp; The result must include terrain data and&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* may optionally include a water mask and an indication of which child tiles are available.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} x The X coordinate of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} y The Y coordinate of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level of the tile for which to request geometry.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Request} [request] The request object. Intended for internal use only.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Promise.&amp;lt;TerrainData&amp;gt;|undefined} A promise for the requested geometry.&amp;nbsp; If this method&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; returns undefined instead of a promise, it is an indication that too many requests are already&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; pending and the request will be retried later.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @exception {DeveloperError} This function must not be called before {@link CesiumTerrainProvider#ready}&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; returns true.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;CesiumTerrainProvider.prototype.requestTileGeometry = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; request&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeStart(&#39;debug&#39;, pragmas.debug)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!this._ready) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;requestTileGeometry must not be called before the terrain provider is ready.&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeEnd(&#39;debug&#39;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var layers = this._layers;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var layerToUse;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var layerCount = layers.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (layerCount === 1) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Optimized path for single layers&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; layerToUse = layers[0];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (var i = 0; i &amp;lt; layerCount; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var layer = layers[i];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; !defined(layer.availability) ||&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; layer.availability.isTileAvailable(level, x, y)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; layerToUse = layer;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; break;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return requestTileGeometry(this, x, y, level, layerToUse, request);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;top=0;left=0;bottom=0;right=0;overflow=hidden;rounded=0;align=left;verticalAlign=top;spacing=6;fillColor=none;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-383">
          <mxGeometry x="686" width="944" height="765" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-387" style="shape=partialRectangle;html=1;whiteSpace=wrap;collapsible=0;dropTarget=0;pointerEvents=0;fillColor=none;top=0;left=0;bottom=0;right=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;strokeWidth=1;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-303">
          <mxGeometry y="1596" width="1630" height="1233" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-388" style="shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;top=0;left=0;bottom=0;right=0;overflow=hidden;rounded=0;align=left;verticalAlign=top;spacing=6;fillColor=none;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-387">
          <mxGeometry width="686" height="1233" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-389" value="&lt;div&gt;&lt;b&gt;function requestTileGeometry(provider, x, y, level, layerToUse, request) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(layerToUse)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return when.reject(new RuntimeError(&quot;Terrain tile doesn&#39;t exist&quot;));&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var urlTemplates = layerToUse.tileUrlTemplates;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (urlTemplates.length === 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // The TileMapService scheme counts from the bottom left&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainY;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!provider._scheme || provider._scheme === &quot;tms&quot;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainY = yTiles - y - 1;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainY = y;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var extensionList = [];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (provider._requestVertexNormals &amp;amp;&amp;amp; layerToUse.hasVertexNormals) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; extensionList.push(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layerToUse.littleEndianExtensionSize&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ? &quot;octvertexnormals&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : &quot;vertexnormals&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (provider._requestWaterMask &amp;amp;&amp;amp; layerToUse.hasWaterMask) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; extensionList.push(&quot;watermask&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (provider._requestMetadata &amp;amp;&amp;amp; layerToUse.hasMetadata) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; extensionList.push(&quot;metadata&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var headers;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var query;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var url = urlTemplates[(x + terrainY + level) % urlTemplates.length];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var resource = layerToUse.resource;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(resource._ionEndpoint) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !defined(resource._ionEndpoint.externalType)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // ion uses query paremeters to request extensions&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (extensionList.length !== 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; query = { extensions: extensionList.join(&quot;-&quot;) };&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; headers = getRequestHeader(undefined);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; //All other terrain servers&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; headers = getRequestHeader(extensionList);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var promise = resource&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; .getDerivedResource({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; url: url,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; templateValues: {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; version: layerToUse.version,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; z: level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; x: x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; y: terrainY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; queryParameters: query,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; headers: headers,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; request: request,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; })&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; .fetchArrayBuffer();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(promise)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return promise.then(function (buffer) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(provider._heightmapStructure)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return createHeightmapTerrainData(provider, buffer, level, x, y);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return createQuantizedMeshTerrainData(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; provider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; buffer,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layerToUse&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="shape=partialRectangle;html=1;whiteSpace=wrap;connectable=0;top=0;left=0;bottom=0;right=0;overflow=hidden;rounded=0;align=left;verticalAlign=top;spacing=6;fillColor=none;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-387">
          <mxGeometry x="686" width="944" height="1233" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-55" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Determines an appropriate geometric error estimate when the geometry comes from a heightmap.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Number} An estimated geometric error.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ellipsoid,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tileImageWidth,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; numberOfTilesAtLevelZero&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; (ellipsoid.maximumRadius *&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; 2 *&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Math.PI *&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; TerrainProvider.heightmapTerrainQuality) /&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; (tileImageWidth * numberOfTilesAtLevelZero)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" parent="O9qtJ-ZTzyiBhBGTBMVZ-49" vertex="1">
          <mxGeometry x="794" y="346" width="656" height="310" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-59" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="O9qtJ-ZTzyiBhBGTBMVZ-49" source="zrCMIupTtKye5h8rk7Vh-380" target="O9qtJ-ZTzyiBhBGTBMVZ-55" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="705" y="2818" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-61" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="O9qtJ-ZTzyiBhBGTBMVZ-49" source="zrCMIupTtKye5h8rk7Vh-381" target="O9qtJ-ZTzyiBhBGTBMVZ-55" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="1409" y="2795" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="_qH6-IZlokEgzrvQ4-RS-102" style="orthogonalLoop=1;jettySize=auto;html=1;startSize=40;strokeColor=#000000;fontSize=25;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="_qH6-IZlokEgzrvQ4-RS-100" target="zrCMIupTtKye5h8rk7Vh-304" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="12236" y="4127" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-69" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="O9qtJ-ZTzyiBhBGTBMVZ-68" target="O9qtJ-ZTzyiBhBGTBMVZ-67" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-139" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="1" source="O9qtJ-ZTzyiBhBGTBMVZ-138" target="O9qtJ-ZTzyiBhBGTBMVZ-137" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="O9qtJ-ZTzyiBhBGTBMVZ-141" style="edgeStyle=none;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="O9qtJ-ZTzyiBhBGTBMVZ-140" target="zrCMIupTtKye5h8rk7Vh-304" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="12731" y="4090" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-20" style="rounded=1;jumpStyle=arc;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="1" source="zrCMIupTtKye5h8rk7Vh-18" target="_qH6-IZlokEgzrvQ4-RS-73">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-51" style="edgeStyle=none;rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="1" source="zrCMIupTtKye5h8rk7Vh-50" target="zrCMIupTtKye5h8rk7Vh-49">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-54" style="edgeStyle=none;rounded=1;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="1" source="zrCMIupTtKye5h8rk7Vh-53" target="zrCMIupTtKye5h8rk7Vh-52">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-56" style="edgeStyle=orthogonalEdgeStyle;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="1" source="zrCMIupTtKye5h8rk7Vh-55" target="_qH6-IZlokEgzrvQ4-RS-35">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="-645" y="975" />
              <mxPoint x="-645" y="9590" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-68" style="rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=10;shape=link;width=50;" edge="1" parent="1" source="_qH6-IZlokEgzrvQ4-RS-34" target="zrCMIupTtKye5h8rk7Vh-57">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="-66.88888888888687" y="9444.111111111113" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-69" style="rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=10;shape=link;width=50;" edge="1" parent="1" source="_qH6-IZlokEgzrvQ4-RS-40" target="zrCMIupTtKye5h8rk7Vh-70">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="-9.003333333332108" y="9515" as="targetPoint" />
            <mxPoint x="1593" y="7827" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-188" value="QuantizedMeshTerrainData.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="11411" y="9064" width="1722" height="2594" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-189" value="&lt;div&gt;&lt;b&gt;var upsampleTaskProcessor = new TaskProcessor(&quot;upsampleQuantizedTerrainMesh&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Upsamples this terrain data for use by a descendant tile.&amp;nbsp; The resulting instance will contain a subset of the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* vertices in this instance, interpolated if necessary.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} thisX The X coordinate of this tile in the tiling scheme.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} thisY The Y coordinate of this tile in the tiling scheme.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} thisLevel The level of this tile in the tiling scheme.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Promise.&amp;lt;QuantizedMeshTerrainData&amp;gt;|undefined} A promise for upsampled heightmap terrain data for the descendant tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; or undefined if too many asynchronous upsample operations are in progress and the request has been&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; deferred.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;QuantizedMeshTerrainData.prototype.upsample = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tilingScheme,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; thisX,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; thisY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; thisLevel,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; descendantX,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; descendantY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; descendantLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeStart(&#39;debug&#39;, pragmas.debug);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(tilingScheme)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;tilingScheme is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(thisX)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;thisX is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(thisY)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;thisY is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(thisLevel)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;thisLevel is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(descendantX)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;descendantX is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(descendantY)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;descendantY is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(descendantLevel)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;descendantLevel is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var levelDifference = descendantLevel - thisLevel;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (levelDifference &amp;gt; 1) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;Upsampling through more than one level at a time is not currently supported.&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeEnd(&#39;debug&#39;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var mesh = this._mesh;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(this._mesh)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var isEastChild = thisX * 2 !== descendantX;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var isNorthChild = thisY * 2 === descendantY;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var ellipsoid = tilingScheme.ellipsoid;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var childRectangle = tilingScheme.tileXYToRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; descendantX,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; descendantY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; descendantLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var upsamplePromise = upsampleTaskProcessor.scheduleTask({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; vertices: mesh.vertices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; vertexCountWithoutSkirts: mesh.vertexCountWithoutSkirts,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; indices: mesh.indices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; indexCountWithoutSkirts: mesh.indexCountWithoutSkirts,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; encoding: mesh.encoding,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; minimumHeight: this._minimumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; maximumHeight: this._maximumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; isEastChild: isEastChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; isNorthChild: isNorthChild,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; childRectangle: childRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ellipsoid: ellipsoid,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; exaggeration: mesh.exaggeration,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(upsamplePromise)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Postponed&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var shortestSkirt = Math.min(this._westSkirtHeight, this._eastSkirtHeight);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; shortestSkirt = Math.min(shortestSkirt, this._southSkirtHeight);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; shortestSkirt = Math.min(shortestSkirt, this._northSkirtHeight);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var westSkirtHeight = isEastChild&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ? shortestSkirt * 0.5&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; : this._westSkirtHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var southSkirtHeight = isNorthChild&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ? shortestSkirt * 0.5&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; : this._southSkirtHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var eastSkirtHeight = isEastChild&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ? this._eastSkirtHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; : shortestSkirt * 0.5;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var northSkirtHeight = isNorthChild&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ? this._northSkirtHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; : shortestSkirt * 0.5;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var credits = this._credits;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return when(upsamplePromise).then(function (result) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var quantizedVertices = new Uint16Array(result.vertices);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var indicesTypedArray = IndexDatatype.createTypedArray(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; quantizedVertices.length / 3,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.indices&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var encodedNormals;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(result.encodedNormals)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; encodedNormals = new Uint8Array(result.encodedNormals);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return new QuantizedMeshTerrainData({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; quantizedVertices: quantizedVertices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indices: indicesTypedArray,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; encodedNormals: encodedNormals,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; minimumHeight: result.minimumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; maximumHeight: result.maximumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingSphere: BoundingSphere.clone(result.boundingSphere),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; orientedBoundingBox: OrientedBoundingBox.clone(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; result.orientedBoundingBox&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; ),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; horizonOcclusionPoint: Cartesian3.clone(result.horizonOcclusionPoint),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; westIndices: result.westIndices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; southIndices: result.southIndices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; eastIndices: result.eastIndices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; northIndices: result.northIndices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; westSkirtHeight: westSkirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; southSkirtHeight: southSkirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; eastSkirtHeight: eastSkirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; northSkirtHeight: northSkirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; childTileMask: 0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; credits: credits,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; createdByUpsampling: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-188">
          <mxGeometry x="114" y="234" width="793" height="2046" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-211" value="&lt;div&gt;&lt;b&gt;var createMeshTaskProcessor = new TaskProcessor(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &quot;createVerticesFromQuantizedTerrainMesh&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Creates a {@link TerrainMesh} from this terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TilingScheme} tilingScheme The tiling scheme to which this tile belongs.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} x The X coordinate of the tile for which to create the terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} y The Y coordinate of the tile for which to create the terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level of the tile for which to create the terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} [exaggeration=1.0] The scale used to exaggerate the terrain.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Promise.&amp;lt;TerrainMesh&amp;gt;|undefined} A promise for the terrain mesh, or undefined if too many&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; asynchronous mesh creations are already in progress and the operation should&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; be retried later.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;QuantizedMeshTerrainData.prototype.createMesh = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tilingScheme,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; exaggeration&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeStart(&#39;debug&#39;, pragmas.debug);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(tilingScheme)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;tilingScheme is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(x)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;x is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(y)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;y is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(level)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;level is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeEnd(&#39;debug&#39;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var ellipsoid = tilingScheme.ellipsoid;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var rectangle = tilingScheme.tileXYToRectangle(x, y, level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; exaggeration = defaultValue(exaggeration, 1.0);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var verticesPromise = createMeshTaskProcessor.scheduleTask({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; minimumHeight: this._minimumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; maximumHeight: this._maximumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; quantizedVertices: this._quantizedVertices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; octEncodedNormals: this._encodedNormals,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; includeWebMercatorT: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; indices: this._indices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; westIndices: this._westIndices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; southIndices: this._southIndices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; eastIndices: this._eastIndices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; northIndices: this._northIndices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; westSkirtHeight: this._westSkirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; southSkirtHeight: this._southSkirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; eastSkirtHeight: this._eastSkirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; northSkirtHeight: this._northSkirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; rectangle: rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; relativeToCenter: this._boundingSphere.center,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ellipsoid: ellipsoid,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; exaggeration: exaggeration,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(verticesPromise)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Postponed&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var that = this;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return when(verticesPromise, function (result) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var vertexCountWithoutSkirts = that._quantizedVertices.length / 3;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var vertexCount =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; vertexCountWithoutSkirts +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._westIndices.length +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._southIndices.length +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._eastIndices.length +&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._northIndices.length;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var indicesTypedArray = IndexDatatype.createTypedArray(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; vertexCount,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.indices&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var vertices = new Float32Array(result.vertices);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var rtc = result.center;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var minimumHeight = result.minimumHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var maximumHeight = result.maximumHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var boundingSphere = defaultValue(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; BoundingSphere.clone(result.boundingSphere),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._boundingSphere&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var obb = defaultValue(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; OrientedBoundingBox.clone(result.orientedBoundingBox),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._orientedBoundingBox&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var occludeePointInScaledSpace = defaultValue(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Cartesian3.clone(result.occludeePointInScaledSpace),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; that._horizonOcclusionPoint&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var stride = result.vertexStride;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var terrainEncoding = TerrainEncoding.clone(result.encoding);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Clone complex result objects because the transfer from the web worker&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // has stripped them down to JSON-style objects.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._mesh = new TerrainMesh(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; rtc,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; vertices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesTypedArray,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.indexCountWithoutSkirts,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; vertexCountWithoutSkirts,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; minimumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; maximumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; boundingSphere,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; occludeePointInScaledSpace,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; stride,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; obb,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; terrainEncoding,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; exaggeration,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.westIndicesSouthToNorth,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.southIndicesEastToWest,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.eastIndicesNorthToSouth,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.northIndicesWestToEast&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Free memory received from server after mesh is created.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._quantizedVertices = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._encodedNormals = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._indices = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._uValues = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._vValues = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._heightValues = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._westIndices = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._southIndices = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._eastIndices = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._northIndices = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return that._mesh;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-188">
          <mxGeometry x="984" y="544" width="619" height="2004" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-192" value="HeightmapTerrainData.js" style="swimlane;swimlaneLine=0;swimlaneFillColor=none;fontSize=100;startSize=148;fontStyle=1;autosize=0;collapsible=1;expand=1;verticalAlign=top;" vertex="1" parent="1">
          <mxGeometry x="13231" y="9064" width="1625" height="2594" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-193" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Upsamples this terrain data for use by a descendant tile.&amp;nbsp; The resulting instance will contain a subset of the&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* height samples in this instance, interpolated if necessary.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} thisX The X coordinate of this tile in the tiling scheme.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} thisY The Y coordinate of this tile in the tiling scheme.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} thisLevel The level of this tile in the tiling scheme.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Promise.&amp;lt;HeightmapTerrainData&amp;gt;|undefined} A promise for upsampled heightmap terrain data for the descendant tile,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; or undefined if too many asynchronous upsample operations are in progress and the request has been&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; deferred.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;HeightmapTerrainData.prototype.upsample = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tilingScheme,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; thisX,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; thisY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; thisLevel,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; descendantX,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; descendantY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; descendantLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeStart(&#39;debug&#39;, pragmas.debug);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(tilingScheme)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;tilingScheme is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(thisX)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;thisX is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(thisY)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;thisY is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(thisLevel)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;thisLevel is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(descendantX)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;descendantX is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(descendantY)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;descendantY is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(descendantLevel)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;descendantLevel is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var levelDifference = descendantLevel - thisLevel;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (levelDifference &amp;gt; 1) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &quot;Upsampling through more than one level at a time is not currently supported.&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeEnd(&#39;debug&#39;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var meshData = this._mesh;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(meshData)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var width = this._width;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var height = this._height;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var structure = this._structure;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var stride = structure.stride;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var heights = new this._bufferType(width * height * stride);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var buffer = meshData.vertices;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var encoding = meshData.encoding;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // PERFORMANCE_IDEA: don&#39;t recompute these rectangles - the caller already knows them.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var sourceRectangle = tilingScheme.tileXYToRectangle(thisX, thisY, thisLevel);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var destinationRectangle = tilingScheme.tileXYToRectangle(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; descendantX,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; descendantY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; descendantLevel&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var heightOffset = structure.heightOffset;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var heightScale = structure.heightScale;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var exaggeration = meshData.exaggeration;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var elementsPerHeight = structure.elementsPerHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var elementMultiplier = structure.elementMultiplier;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var isBigEndian = structure.isBigEndian;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var divisor = Math.pow(elementMultiplier, elementsPerHeight - 1);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; for (var j = 0; j &amp;lt; height; ++j) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var latitude = CesiumMath.lerp(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; destinationRectangle.north,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; destinationRectangle.south,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; j / (height - 1)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; for (var i = 0; i &amp;lt; width; ++i) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var longitude = CesiumMath.lerp(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; destinationRectangle.west,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; destinationRectangle.east,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; i / (width - 1)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; var heightSample = interpolateMeshHeight(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; buffer,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; encoding,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; heightOffset,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; heightScale,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; sourceRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; width,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; height,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; longitude,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; latitude,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; exaggeration&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // Use conditionals here instead of Math.min and Math.max so that an undefined&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; // lowestEncodedHeight or highestEncodedHeight has no effect.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; heightSample =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; heightSample &amp;lt; structure.lowestEncodedHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ? structure.lowestEncodedHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : heightSample;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; heightSample =&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; heightSample &amp;gt; structure.highestEncodedHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ? structure.highestEncodedHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : heightSample;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; setHeight(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; heights,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; elementsPerHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; elementMultiplier,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; divisor,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; stride,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; isBigEndian,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; j * width + i,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; heightSample&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return new HeightmapTerrainData({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; buffer: heights,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; width: width,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; height: height,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; childTileMask: 0,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; structure: this._structure,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; createdByUpsampling: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-192">
          <mxGeometry x="114" y="234" width="767" height="2046" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-214" value="&lt;div&gt;&lt;b&gt;/**&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* Creates a {@link TerrainMesh} from this terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @private&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {TilingScheme} tilingScheme The tiling scheme to which this tile belongs.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} x The X coordinate of the tile for which to create the terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} y The Y coordinate of the tile for which to create the terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} level The level of the tile for which to create the terrain data.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @param {Number} [exaggeration=1.0] The scale used to exaggerate the terrain.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;* @returns {Promise.&amp;lt;TerrainMesh&amp;gt;|undefined} A promise for the terrain mesh, or undefined if too many&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; asynchronous mesh creations are already in progress and the operation should&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; be retried later.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp;*/&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;HeightmapTerrainData.prototype.createMesh = function (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; tilingScheme,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; exaggeration&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeStart(&#39;debug&#39;, pragmas.debug);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(tilingScheme)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;tilingScheme is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(x)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;x is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(y)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;y is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(level)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; throw new DeveloperError(&quot;level is required.&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; //&amp;gt;&amp;gt;includeEnd(&#39;debug&#39;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var ellipsoid = tilingScheme.ellipsoid;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var nativeRectangle = tilingScheme.tileXYToNativeRectangle(x, y, level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var rectangle = tilingScheme.tileXYToRectangle(x, y, level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; exaggeration = defaultValue(exaggeration, 1.0);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // Compute the center of the tile for RTC rendering.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var center = ellipsoid.cartographicToCartesian(Rectangle.center(rectangle));&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var structure = this._structure;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var levelZeroMaxError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ellipsoid,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; this._width,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; tilingScheme.getNumberOfXTilesAtLevel(0)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var thisLevelMaxError = levelZeroMaxError / (1 &amp;lt;&amp;lt; level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; this._skirtHeight = Math.min(thisLevelMaxError * 4.0, 1000.0);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var verticesPromise = taskProcessor.scheduleTask({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; heightmap: this._buffer,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; structure: structure,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; includeWebMercatorT: true,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; width: this._width,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; height: this._height,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; nativeRectangle: nativeRectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; rectangle: rectangle,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; relativeToCenter: center,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; ellipsoid: ellipsoid,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; skirtHeight: this._skirtHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; isGeographic: tilingScheme.projection instanceof GeographicProjection,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; exaggeration: exaggeration,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; encoding: this._encoding,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(verticesPromise)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Postponed&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var that = this;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return when(verticesPromise, function (result) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var indicesAndEdges;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (that._skirtHeight &amp;gt; 0.0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesAndEdges = TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; result.gridWidth,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; result.gridHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesAndEdges = TerrainProvider.getRegularGridIndicesAndEdgeIndices(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; result.gridWidth,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; result.gridHeight&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var vertexCountWithoutSkirts = result.gridWidth * result.gridHeight;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Clone complex result objects because the transfer from the web worker&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // has stripped them down to JSON-style objects.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._mesh = new TerrainMesh(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; center,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; new Float32Array(result.vertices),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesAndEdges.indices,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesAndEdges.indexCountWithoutSkirts,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; vertexCountWithoutSkirts,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.minimumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.maximumHeight,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; BoundingSphere.clone(result.boundingSphere3D),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; Cartesian3.clone(result.occludeePointInScaledSpace),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; result.numberOfAttributes,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; OrientedBoundingBox.clone(result.orientedBoundingBox),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; TerrainEncoding.clone(result.encoding),&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; exaggeration,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesAndEdges.westIndicesSouthToNorth,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesAndEdges.southIndicesEastToWest,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesAndEdges.eastIndicesNorthToSouth,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; indicesAndEdges.northIndicesWestToEast&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // Free memory received from server after mesh is created.&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; that._buffer = undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return that._mesh;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;};&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="zrCMIupTtKye5h8rk7Vh-192">
          <mxGeometry x="962" y="838" width="619" height="1682" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-195" style="rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="1" source="zrCMIupTtKye5h8rk7Vh-194" target="zrCMIupTtKye5h8rk7Vh-189">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-196" style="edgeStyle=none;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="1" source="zrCMIupTtKye5h8rk7Vh-194" target="zrCMIupTtKye5h8rk7Vh-193">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-213" style="edgeStyle=none;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="1" source="zrCMIupTtKye5h8rk7Vh-212" target="zrCMIupTtKye5h8rk7Vh-211">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-215" style="edgeStyle=none;rounded=1;sketch=0;jumpStyle=none;jumpSize=20;orthogonalLoop=1;jettySize=auto;html=1;shadow=0;targetPerimeterSpacing=0;strokeColor=#000000;strokeWidth=1;" edge="1" parent="1" source="zrCMIupTtKye5h8rk7Vh-212" target="zrCMIupTtKye5h8rk7Vh-214">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="zrCMIupTtKye5h8rk7Vh-386" value="&lt;div&gt;&lt;b&gt;function requestTileGeometry(provider, x, y, level, layerToUse, request) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(layerToUse)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return when.reject(new RuntimeError(&quot;Terrain tile doesn&#39;t exist&quot;));&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var urlTemplates = layerToUse.tileUrlTemplates;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (urlTemplates.length === 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; // The TileMapService scheme counts from the bottom left&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var terrainY;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!provider._scheme || provider._scheme === &quot;tms&quot;) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; var yTiles = provider._tilingScheme.getNumberOfYTilesAtLevel(level);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainY = yTiles - y - 1;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; terrainY = y;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var extensionList = [];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (provider._requestVertexNormals &amp;amp;&amp;amp; layerToUse.hasVertexNormals) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; extensionList.push(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layerToUse.littleEndianExtensionSize&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; ? &quot;octvertexnormals&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; : &quot;vertexnormals&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (provider._requestWaterMask &amp;amp;&amp;amp; layerToUse.hasWaterMask) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; extensionList.push(&quot;watermask&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (provider._requestMetadata &amp;amp;&amp;amp; layerToUse.hasMetadata) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; extensionList.push(&quot;metadata&quot;);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var headers;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var query;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var url = urlTemplates[(x + terrainY + level) % urlTemplates.length];&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var resource = layerToUse.resource;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; defined(resource._ionEndpoint) &amp;amp;&amp;amp;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; !defined(resource._ionEndpoint.externalType)&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; ) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; // ion uses query paremeters to request extensions&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (extensionList.length !== 0) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; query = { extensions: extensionList.join(&quot;-&quot;) };&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; headers = getRequestHeader(undefined);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; } else {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; //All other terrain servers&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; headers = getRequestHeader(extensionList);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; var promise = resource&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; .getDerivedResource({&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; url: url,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; templateValues: {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; version: layerToUse.version,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; z: level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; x: x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; y: terrainY,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; },&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; queryParameters: query,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; headers: headers,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; request: request,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; })&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; .fetchArrayBuffer();&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; if (!defined(promise)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return undefined;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; return promise.then(function (buffer) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; if (defined(provider._heightmapStructure)) {&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; return createHeightmapTerrainData(provider, buffer, level, x, y);&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; }&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; return createQuantizedMeshTerrainData(&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; provider,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; buffer,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; level,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; x,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; y,&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; layerToUse&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; &amp;nbsp; );&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;&amp;nbsp; });&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;b&gt;}&lt;/b&gt;&lt;/div&gt;" style="text;html=1;resizable=0;autosize=1;align=left;verticalAlign=top;points=[];rounded=0;backgroundOutline=0;container=1;strokeColor=#000000;spacing=6;imageAspect=1;fillColor=#CCFFFF;collapsible=0;rotatable=0;" vertex="1" parent="1">
          <mxGeometry x="14351" y="4538" width="436" height="1220" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
